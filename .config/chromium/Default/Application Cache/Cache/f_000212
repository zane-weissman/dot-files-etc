//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : bond_const.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var BondDataType;
        (function (BondDataType) {
            BondDataType[BondDataType["BT_STOP"] = 0] = "BT_STOP";
            BondDataType[BondDataType["BT_STOP_BASE"] = 1] = "BT_STOP_BASE";
            BondDataType[BondDataType["BT_BOOL"] = 2] = "BT_BOOL";
            BondDataType[BondDataType["BT_UINT8"] = 3] = "BT_UINT8";
            BondDataType[BondDataType["BT_UINT16"] = 4] = "BT_UINT16";
            BondDataType[BondDataType["BT_UINT32"] = 5] = "BT_UINT32";
            BondDataType[BondDataType["BT_UINT64"] = 6] = "BT_UINT64";
            BondDataType[BondDataType["BT_FLOAT"] = 7] = "BT_FLOAT";
            BondDataType[BondDataType["BT_DOUBLE"] = 8] = "BT_DOUBLE";
            BondDataType[BondDataType["BT_STRING"] = 9] = "BT_STRING";
            BondDataType[BondDataType["BT_STRUCT"] = 10] = "BT_STRUCT";
            BondDataType[BondDataType["BT_LIST"] = 11] = "BT_LIST";
            BondDataType[BondDataType["BT_SET"] = 12] = "BT_SET";
            BondDataType[BondDataType["BT_MAP"] = 13] = "BT_MAP";
            BondDataType[BondDataType["BT_INT8"] = 14] = "BT_INT8";
            BondDataType[BondDataType["BT_INT16"] = 15] = "BT_INT16";
            BondDataType[BondDataType["BT_INT32"] = 16] = "BT_INT32";
            BondDataType[BondDataType["BT_INT64"] = 17] = "BT_INT64";
            BondDataType[BondDataType["BT_WSTRING"] = 18] = "BT_WSTRING";
            BondDataType[BondDataType["BT_UNAVAILABLE"] = 127] = "BT_UNAVAILABLE";
        })(BondDataType = Bond.BondDataType || (Bond.BondDataType = {}));
        var ProtocolType;
        (function (ProtocolType) {
            ProtocolType[ProtocolType["MARSHALED_PROTOCOL"] = 0] = "MARSHALED_PROTOCOL";
            ProtocolType[ProtocolType["MAFIA_PROTOCOL"] = 17997] = "MAFIA_PROTOCOL";
            ProtocolType[ProtocolType["COMPACT_PROTOCOL"] = 16963] = "COMPACT_PROTOCOL";
            ProtocolType[ProtocolType["JSON_PROTOCOL"] = 21322] = "JSON_PROTOCOL";
            ProtocolType[ProtocolType["PRETTY_JSON_PROTOCOL"] = 20554] = "PRETTY_JSON_PROTOCOL";
            ProtocolType[ProtocolType["SIMPLE_PROTOCOL"] = 20563] = "SIMPLE_PROTOCOL";
        })(ProtocolType = Bond.ProtocolType || (Bond.ProtocolType = {}));
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
;
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var Collections;
        (function (Collections) {
            var Set = (function () {
                function Set() {
                    this._buffer = [];
                }
                Set.prototype.Add = function (t) {
                    var i = 0;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i] == t) {
                            break;
                        }
                    }
                    if (i == this._buffer.length) {
                        this._buffer.push(t);
                    }
                };
                Set.prototype.Count = function () {
                    return this._buffer.length;
                };
                Set.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return Set;
            }());
            Collections.Set = Set;
            // Modified bond code to add AddorReplace and Remove for Map
            //TODO(abpanwar): Contact the bond team to add this to their library.
            var Map = (function () {
                function Map() {
                    this._buffer = [];
                }
                Map.prototype.Add = function (key, value) {
                    if (this._getIndex(key) == -1) {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };
                Map.prototype.AddOrReplace = function (key, value) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        this._buffer[i] = { Key: key, Value: value };
                    }
                    else {
                        this._buffer.push({ Key: key, Value: value });
                    }
                };
                Map.prototype.Remove = function (key) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        this._buffer.splice(i, 1);
                    }
                };
                Map.prototype.Count = function () {
                    return this._buffer.length;
                };
                Map.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                Map.prototype.ContainsKey = function (key) {
                    if (this._getIndex(key) >= 0) {
                        return true;
                    }
                    return false;
                };
                Map.prototype.Get = function (key) {
                    var i = this._getIndex(key);
                    if (i >= 0) {
                        return this._buffer[i].Value;
                    }
                    return null;
                };
                Map.prototype._getIndex = function (key) {
                    var i = 0;
                    var index = -1;
                    for (; i < this._buffer.length; ++i) {
                        if (this._buffer[i].Key == key) {
                            index = i;
                            break;
                        }
                    }
                    return index;
                };
                return Map;
            }());
            Collections.Map = Map;
        })(Collections = Bond.Collections || (Bond.Collections = {}));
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
;
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var Encoding;
        (function (Encoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetBytes = function (value) {
                    var array = [];
                    for (var i = 0; i < value.length; ++i) {
                        var char = value.charCodeAt(i);
                        if (char < 0x80) {
                            array.push(char);
                        }
                        else if (char < 0x800) {
                            array.push(0xc0 | (char >> 6), 0x80 | (char & 0x3f));
                        }
                        else if (char < 0xd800 || char >= 0xe000) {
                            array.push(0xe0 | (char >> 12), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        }
                        else {
                            char = 0x10000 + (((char & 0x3ff) << 10) | (value.charCodeAt(++i) & 0x3ff));
                            array.push(0xf0 | (char >> 18), 0x80 | ((char >> 12) & 0x3f), 0x80 | ((char >> 6) & 0x3f), 0x80 | (char & 0x3f));
                        }
                    }
                    return array;
                };
                return Utf8;
            }());
            Encoding.Utf8 = Utf8;
            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetString = function (inArray) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var output = [];
                    var paddingBytes = inArray.length % 3;
                    var i, temp, length;
                    var toBase64 = function (num) {
                        return [lookup.charAt((num >> 18) & 0x3F),
                            lookup.charAt((num >> 12) & 0x3F),
                            lookup.charAt((num >> 6) & 0x3F),
                            lookup.charAt(num & 0x3F)].join("");
                    };
                    for (i = 0, length = inArray.length - paddingBytes; i < length; i += 3) {
                        temp = (inArray[i] << 16) + (inArray[i + 1] << 8) + (inArray[i + 2]);
                        output.push(toBase64(temp));
                    }
                    switch (paddingBytes) {
                        case 1:
                            temp = inArray[inArray.length - 1];
                            output.push(lookup.charAt(temp >> 2));
                            output.push(lookup.charAt((temp << 4) & 0x3F));
                            output.push('==');
                            break;
                        case 2:
                            temp = (inArray[inArray.length - 2] << 8) + (inArray[inArray.length - 1]);
                            output.push(lookup.charAt(temp >> 10));
                            output.push(lookup.charAt((temp >> 4) & 0x3F));
                            output.push(lookup.charAt((temp << 2) & 0x3F));
                            output.push('=');
                            break;
                    }
                    return output.join("");
                };
                return Base64;
            }());
            Encoding.Base64 = Base64;
            var Varint = (function () {
                function Varint() {
                }
                Varint.GetBytes = function (value) {
                    var array = [];
                    while (value & 0xffffff80) {
                        array.push((value & 0x7f) | 0x80);
                        value >>>= 7;
                    }
                    array.push(value & 0x7f);
                    return array;
                };
                return Varint;
            }());
            Encoding.Varint = Varint;
            var Varint64 = (function () {
                function Varint64() {
                }
                Varint64.GetBytes = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var array = [];
                    while (high || (0xffffff80 & low)) {
                        array.push((low & 0x7f) | 0x80);
                        low = ((high & 0x7f) << 25) | (low >>> 7);
                        high >>>= 7;
                    }
                    array.push(low & 0x7f);
                    return array;
                };
                return Varint64;
            }());
            Encoding.Varint64 = Varint64;
            var Float = (function () {
                function Float() {
                }
                Float.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        view.setFloat32(0, value, true /*littleEndian*/);
                        var array = [];
                        for (var i = 0; i < 4; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    }
                    else {
                        return FloatUtils.ConvertNumberToArray(value, false /*isDouble*/);
                    }
                };
                return Float;
            }());
            Encoding.Float = Float;
            // Note: see notes of Float.
            var Double = (function () {
                function Double() {
                }
                Double.GetBytes = function (value) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        view.setFloat64(0, value, true /*littleEndian*/);
                        var array = [];
                        for (var i = 0; i < 8; ++i) {
                            array.push(view.getUint8(i));
                        }
                        return array;
                    }
                    else {
                        return FloatUtils.ConvertNumberToArray(value, true /*isDouble*/);
                    }
                };
                return Double;
            }());
            Encoding.Double = Double;
            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.EncodeZigzag16 = function (value) {
                    value = Bond.Number.ToInt16(value);
                    return ((value << 1) ^ (value >> (2 /*sizeof(short)*/ * 8 - 1)));
                };
                Zigzag.EncodeZigzag32 = function (value) {
                    value = Bond.Number.ToInt32(value);
                    return ((value << 1) ^ (value >> (4 /*sizeof(int)*/ * 8 - 1)));
                };
                Zigzag.EncodeZigzag64 = function (value) {
                    var low = value.low;
                    var high = value.high;
                    var tmpH = (high << 1) | (low >>> 31);
                    var tmpL = low << 1;
                    if (high & 0x80000000) {
                        tmpH = ~tmpH;
                        tmpL = ~tmpL;
                    }
                    var res = new Bond.UInt64("0");
                    res.low = tmpL;
                    res.high = tmpH;
                    return res;
                };
                return Zigzag;
            }());
            Encoding.Zigzag = Zigzag;
        })(Encoding = Bond.Encoding || (Bond.Encoding = {}));
        var Decoding;
        (function (Decoding) {
            var Utf8 = (function () {
                function Utf8() {
                }
                Utf8.GetString = function (data) {
                    var res = [];
                    for (var i = 0; i < data.length; ++i) {
                        var c1 = data[i];
                        if (c1 <= 191) {
                            res.push(String.fromCharCode(c1));
                        }
                        else if (c1 <= 223) {
                            var c2 = data[++i];
                            res.push(String.fromCharCode(((c1 & 31) << 6) | (c2 & 63)));
                        }
                        else if (c1 <= 239) {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            res.push(String.fromCharCode(((c1 & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63)));
                        }
                        else {
                            var c2 = data[++i];
                            var c3 = data[++i];
                            var c4 = data[++i];
                            c1 = ((c1 & 7) << 18) | ((c2 & 63) << 12) | ((c3 & 63) << 6) | (c4 & 63);
                            c1 -= 0x10000;
                            res.push(String.fromCharCode(0xd800 | ((c1 >> 10) & 0x3ff)));
                            res.push(String.fromCharCode(0xdc00 | (c1 & 0x3ff)));
                        }
                    }
                    return res.join("");
                };
                return Utf8;
            }());
            Decoding.Utf8 = Utf8;
            var Base64 = (function () {
                function Base64() {
                }
                Base64.GetBytes = function (base64Str) {
                    var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                    var res = [];
                    for (var i = 0; i < base64Str.length; ++i) {
                        var byte1 = lookup.indexOf(base64Str.charAt(i++));
                        var byte2 = lookup.indexOf(base64Str.charAt(i++));
                        var byte3 = lookup.indexOf(base64Str.charAt(i++));
                        var byte4 = lookup.indexOf(base64Str.charAt(i));
                        res.push(byte1 << 2 | byte2 >> 4);
                        if (byte3 >= 0) {
                            res.push((byte2 << 4) & 0xF0 | byte3 >> 2);
                            if (byte4 >= 0) {
                                res.push((byte3 << 6) & 0xC0 | byte4);
                            }
                        }
                    }
                    return res;
                };
                return Base64;
            }());
            Decoding.Base64 = Base64;
            var Varint = (function () {
                function Varint() {
                }
                Varint.GetInt64 = function (buffer) {
                    var int64 = new Microsoft.Bond.Int64("0");
                    var data = this._Read(buffer);
                    int64.low = data[0];
                    if (data.length > 1) {
                        int64.high = data[1];
                    }
                    return int64;
                };
                Varint.GetNumber = function (buffer) {
                    return this._Read(buffer)[0];
                };
                Varint._Read = function (buffer) {
                    var result = [];
                    var tmp = 0;
                    var hasMore = true;
                    var readedBits = 0;
                    // first, lets try to read the first 32 bits
                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        if (readedBits < 28) {
                            tmp |= raw << readedBits;
                            readedBits += 7;
                        }
                        else {
                            // only lower 4 bits can be put
                            tmp |= raw << readedBits;
                            result.push(tmp);
                            tmp = raw >> 4;
                            readedBits = 3;
                            break;
                        }
                    }
                    // then, read the second 32 bits
                    while (hasMore) {
                        var raw = buffer.shift();
                        hasMore = (raw & 0x80) != 0;
                        raw = raw & 0x7F;
                        tmp |= raw << readedBits;
                        readedBits += 7;
                        if (readedBits >= 32) {
                            break;
                        }
                    }
                    result.push(tmp);
                    return result;
                };
                return Varint;
            }());
            Decoding.Varint = Varint;
            var Float = (function () {
                function Float() {
                }
                Float.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(4));
                        for (var i = 0; i < 4; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat32(0, true /*littleEndian*/);
                    }
                    else {
                        return FloatUtils.ConvertArrayToNumber(buffer, false /*isDouble*/);
                    }
                };
                return Float;
            }());
            Decoding.Float = Float;
            var Double = (function () {
                function Double() {
                }
                Double.GetNumber = function (buffer) {
                    if (Bond.BrowserChecker.IsDataViewSupport()) {
                        var view = new DataView(new ArrayBuffer(8));
                        for (var i = 0; i < 8; ++i) {
                            view.setUint8(i, buffer[i]);
                        }
                        return view.getFloat64(0, true /*littleEndian*/);
                    }
                    else {
                        return FloatUtils.ConvertArrayToNumber(buffer, true /*isDouble*/);
                    }
                };
                return Double;
            }());
            Decoding.Double = Double;
            var Zigzag = (function () {
                function Zigzag() {
                }
                Zigzag.DecodeZigzag16 = function (value) {
                    return (((0xffff & value) >>> 1) ^ (-(value & 1))) << 16 >> 16;
                };
                Zigzag.DecodeZigzag32 = function (value) {
                    return (value >>> 1) ^ (-(value & 1));
                };
                Zigzag.DecodeZigzag64 = function (value) {
                    // implement
                    // (value >>> 1) ^ (-(value & 1))
                    var tmpH = value.high & 1;
                    var high = value.high >>> 1;
                    var tmpL = value.low & 1;
                    var low = value.low >>> 1;
                    low = tmpH << 31 | low;
                    if (tmpL) {
                        low ^= 0xffffffff;
                        high ^= 0xffffffff;
                    }
                    var res = new Microsoft.Bond.UInt64("0");
                    res.low = low;
                    res.high = high;
                    return res;
                };
                return Zigzag;
            }());
            Decoding.Zigzag = Zigzag;
        })(Decoding = Bond.Decoding || (Bond.Decoding = {}));
        /** This class will be used to convert float/double to byte array on browsers which doesn't
            support html5.

            Format: IEEE-754, littleEndian, http://en.wikipedia.org/wiki/IEEE_754-1985

            \note
            1. Don't have negative zero. All zero will be positive zero.
            2. If the buffer array passed to ConvertArrayToFloat() is actual NaN or Inifinity value,
               exception will be raised.
        */
        var FloatUtils = (function () {
            function FloatUtils() {
            }
            FloatUtils.ConvertNumberToArray = function (num, isDouble) {
                if (!num) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }
                var exponentBits = isDouble ? 11 : 8;
                var precisionBits = isDouble ? 52 : 23;
                // follow IEEE-754, exponent bias is 2^(k-1)-1 where k is the number of bits
                // in the exponent: http://en.wikipedia.org/wiki/Exponent_bias
                var bias = (1 << (exponentBits - 1)) - 1;
                var minExponent = 1 - bias;
                var maxExponent = bias;
                var sign = num < 0 ? 1 : 0;
                num = Math.abs(num);
                var intPart = Math.floor(num);
                var floatPart = num - intPart;
                var len = 2 * (bias + 2) + precisionBits;
                var buffer = new Array(len);
                var i = 0;
                while (i < len) {
                    buffer[i++] = 0;
                }
                // caculate the intPart
                i = bias + 2;
                while (i && intPart) {
                    buffer[--i] = intPart % 2;
                    intPart = Math.floor(intPart / 2);
                }
                // caculate the floatPart
                i = bias + 1;
                while (i < len - 1 && floatPart > 0) {
                    floatPart *= 2;
                    if (floatPart >= 1) {
                        buffer[++i] = 1;
                        --floatPart;
                    }
                    else {
                        buffer[++i] = 0;
                    }
                }
                // find the first 1
                var firstBit = 0;
                for (; firstBit < len && !buffer[firstBit]; ++firstBit)
                    ;
                // caculate exponent
                var exponent = bias + 1 - firstBit;
                // caculate round
                var lastBit = firstBit + precisionBits;
                if (buffer[lastBit + 1]) {
                    for (i = lastBit; i > firstBit; --i) {
                        if (buffer[i] = 1 - buffer[i]) {
                            break;
                        }
                    }
                    if (i == firstBit) {
                        ++exponent;
                    }
                }
                // check overflow
                if (exponent > maxExponent || intPart) {
                    if (sign) {
                        return isDouble ? this._doubleNegInifinity : this._floatNegInifinity;
                    }
                    else {
                        return isDouble ? this._doubleInifinity : this._floatInifinity;
                    }
                }
                else if (exponent < minExponent) {
                    return isDouble ? this._doubleZero : this._floatZero;
                }
                // caculate the result
                if (isDouble) {
                    var high = 0;
                    for (i = 0; i < 20; ++i) {
                        high = (high << 1) | buffer[++firstBit];
                    }
                    var low = 0;
                    for (; i < 52; ++i) {
                        low = (low << 1) | buffer[++firstBit];
                    }
                    high |= (exponent + bias) << 20;
                    high = (sign << 31) | (high & 0x7FFFFFFF);
                    var resArray = [low & 0xff, (low >> 8) & 0xff, (low >> 16) & 0xff, low >>> 24,
                        high & 0xff, (high >> 8) & 0xff, (high >> 16) & 0xff, high >>> 24];
                    return resArray;
                }
                else {
                    var result = 0;
                    for (i = 0; i < 23; ++i) {
                        result = (result << 1) | buffer[++firstBit];
                    }
                    result |= (exponent + bias) << 23;
                    result = (sign << 31) | (result & 0x7FFFFFFF);
                    var resArray = [result & 0xff, (result >> 8) & 0xff, (result >> 16) & 0xff, result >>> 24];
                    return resArray;
                }
            };
            FloatUtils.ConvertArrayToNumber = function (buffer, isDouble) {
                var exponentBits = isDouble ? 11 : 8;
                var bias = (1 << (exponentBits - 1)) - 1;
                var sign = (buffer[isDouble ? 7 : 3] & 0x80) != 0;
                var exponent = isDouble ? ((buffer[7] & 0x7f) << 4) | ((buffer[6] & 0xf0) >> 4) : ((buffer[3] & 0x7f) << 1) | ((buffer[2] & 0x80) >> 7);
                // check the buffer is valid or not. If it is invalid (NaN, Infinitive), throw execption.
                if (exponent == 0xff) {
                    throw new Bond.Exception("Not a valid float/double buffer.");
                }
                var res = 1;
                var e = 1;
                if (isDouble) {
                    var high = ((buffer[6] & 0xf) << 28) | ((buffer[5] & 0xff) << 20) | ((buffer[4] & 0xff) << 12);
                    var low = (buffer[3] << 24) | ((buffer[2] & 0xff) << 16) | ((buffer[1] & 0xff) << 8) | (buffer[0] & 0xff);
                    if (!exponent && !high && !low) {
                        return 0.0;
                    }
                    for (var i = 0; i < 20; ++i) {
                        e /= 2;
                        if (high < 0) {
                            res += e;
                        }
                        high <<= 1;
                    }
                    for (var i = 0; i < 32; ++i) {
                        e /= 2;
                        if (low < 0) {
                            res += e;
                        }
                        low <<= 1;
                    }
                }
                else {
                    var data = ((buffer[2] & 0x7f) << 25) | ((buffer[1] & 0xff) << 17) | ((buffer[0] & 0xff) << 9);
                    if (!exponent && !data) {
                        return 0.0;
                    }
                    for (var i = 0; i < 23; ++i) {
                        e /= 2;
                        if (data < 0) {
                            res += e;
                        }
                        data <<= 1;
                    }
                }
                res *= Math.pow(2, exponent - bias);
                return sign ? 0 - res : res;
            };
            return FloatUtils;
        }());
        FloatUtils._floatZero = [0x00, 0x00, 0x00, 0x00];
        FloatUtils._doubleZero = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];
        FloatUtils._floatInifinity = [0x00, 0x00, 0x80, 0x7F];
        FloatUtils._floatNegInifinity = [0x00, 0x00, 0x80, 0xFF];
        FloatUtils._doubleInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x7f];
        FloatUtils._doubleNegInifinity = [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0xff];
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
;
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var IO;
        (function (IO) {
            var MemoryStream = (function () {
                function MemoryStream() {
                    this._buffer = [];
                }
                /*override*/
                MemoryStream.prototype.WriteByte = function (byte) {
                    this._buffer.push(Bond.Number.ToByte(byte));
                };
                /*override*/
                MemoryStream.prototype.Write = function (buffer, offset, count) {
                    while (count--) {
                        this.WriteByte(buffer[offset++]);
                    }
                };
                /**
                 * Returns the array of unsigned bytes from which this stream was created.
                 */
                MemoryStream.prototype.GetBuffer = function () {
                    return this._buffer;
                };
                return MemoryStream;
            }());
            IO.MemoryStream = MemoryStream;
        })(IO = Bond.IO || (Bond.IO = {}));
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
;
var Microsoft;
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var FieldTag = (function () {
            function FieldTag(type, id) {
                this.Type = type;
                this.Id = id;
            }
            return FieldTag;
        }());
        Bond.FieldTag = FieldTag;
        var ContainerTag = (function () {
            function ContainerTag(elementType, size) {
                this.ElementType = elementType;
                this.Size = size;
            }
            return ContainerTag;
        }());
        Bond.ContainerTag = ContainerTag;
        var KeyValueContainerTag = (function () {
            function KeyValueContainerTag(keyType, valueType, size) {
                this.KeyType = keyType;
                this.ValueType = valueType;
                this.Size = size;
            }
            return KeyValueContainerTag;
        }());
        Bond.KeyValueContainerTag = KeyValueContainerTag;
        var Bonded = (function () {
            function Bonded() {
            }
            return Bonded;
        }());
        Bond.Bonded = Bonded;
        var Int64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function Int64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
                if (this.low < 0) {
                    this.high = -1;
                }
            }
            Int64.prototype.Equals = function (numberStr) {
                var tmp = new Int64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return Int64;
        }());
        Bond.Int64 = Int64;
        var UInt64 = (function () {
            // BUG!!: need implement, currently, just handle 32bits number
            function UInt64(numberStr) {
                this.low = 0;
                this.high = 0;
                this.low = parseInt(numberStr);
            }
            UInt64.prototype.Equals = function (numberStr) {
                var tmp = new UInt64(numberStr);
                return this.low == tmp.low && this.high == tmp.high;
            };
            return UInt64;
        }());
        Bond.UInt64 = UInt64;
        var Number = (function () {
            function Number() {
            }
            Number.ToByte = function (value) {
                return this.ToUInt8(value);
            };
            Number.ToInt8 = function (value) {
                var signMask = (value & 0x80) << 24 >> 24;
                return (value & 0x7f) | signMask;
            };
            Number.ToInt16 = function (value) {
                var signMask = (value & 0x8000) << 16 >> 16;
                return (value & 0x7fff) | signMask;
            };
            Number.ToInt32 = function (value) {
                var signMask = (value & 0x80000000);
                return (value & 0x7fffffff) | signMask;
            };
            Number.ToUInt8 = function (value) {
                return value & 0xff;
            };
            Number.ToUInt16 = function (value) {
                return value & 0xffff;
            };
            Number.ToUInt32 = function (value) {
                return value & 0xffffffff;
            };
            return Number;
        }());
        Bond.Number = Number;
        var Exception = (function () {
            function Exception(message) {
                this.Message = message;
            }
            return Exception;
        }());
        Bond.Exception = Exception;
        var KeyValuePair = (function () {
            function KeyValuePair() {
            }
            return KeyValuePair;
        }());
        Bond.KeyValuePair = KeyValuePair;
        ;
        var BrowserChecker = (function () {
            function BrowserChecker() {
            }
            BrowserChecker.IsDataViewSupport = function () {
                return typeof ArrayBuffer != "undefined" &&
                    typeof DataView != "undefined";
            };
            return BrowserChecker;
        }());
        Bond.BrowserChecker = BrowserChecker;
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
(function (Microsoft) {
    var Bond;
    (function (Bond) {
        var CompactBinaryProtocolWriter = (function () {
            function CompactBinaryProtocolWriter(stream) {
                this._stream = stream;
            }
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBlob = function (blob) {
                this._stream.Write(blob, 0, blob.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteBool = function (value) {
                this._stream.WriteByte(value ? 1 : 0);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerBegin = function (size, elementType) {
                this.WriteUInt8(elementType);
                this.WriteUInt32(size);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteMapContainerBegin = function (size, keyType, valueType) {
                this.WriteUInt8(keyType);
                this.WriteUInt8(valueType);
                this.WriteUInt32(size);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteContainerEnd = function () {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteDouble = function (value) {
                var array = Bond.Encoding.Double.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFloat = function (value) {
                var array = Bond.Encoding.Float.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldBegin = function (type, id, metadata) {
                if (id <= 5) {
                    this._stream.WriteByte(type | (id << 5));
                }
                else if (id <= 0xff) {
                    this._stream.WriteByte(type | (6 << 5));
                    this._stream.WriteByte(id);
                }
                else {
                    this._stream.WriteByte(type | (7 << 5));
                    this._stream.WriteByte(id);
                    this._stream.WriteByte(id >> 8);
                }
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldEnd = function () {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteFieldOmitted = function (type, id, metadata) {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt16 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag16(value);
                this.WriteUInt16(value);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt32 = function (value) {
                value = Bond.Encoding.Zigzag.EncodeZigzag32(value);
                this.WriteUInt32(value);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt64 = function (value) {
                this.WriteUInt64(Bond.Encoding.Zigzag.EncodeZigzag64(value));
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToInt8(value));
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteString = function (value) {
                if (value == "") {
                    this.WriteUInt32(0 /*length*/);
                }
                else {
                    var array = Bond.Encoding.Utf8.GetBytes(value);
                    this.WriteUInt32(array.length);
                    this._stream.Write(array, 0, array.length);
                }
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructBegin = function (metadata, isBase) {
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteStructEnd = function (isBase) {
                this.WriteUInt8(isBase ? Bond.BondDataType.BT_STOP_BASE : Bond.BondDataType.BT_STOP);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt16 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt16(value));
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt32 = function (value) {
                var array = Bond.Encoding.Varint.GetBytes(Bond.Number.ToUInt32(value));
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt64 = function (value) {
                var array = Bond.Encoding.Varint64.GetBytes(value);
                this._stream.Write(array, 0, array.length);
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteUInt8 = function (value) {
                this._stream.WriteByte(Bond.Number.ToUInt8(value));
            };
            /*override*/
            CompactBinaryProtocolWriter.prototype.WriteWString = function (value) {
                this.WriteUInt32(value.length);
                for (var i = 0; i < value.length; ++i) {
                    var charCode = value.charCodeAt(i);
                    this._stream.WriteByte(charCode);
                    this._stream.WriteByte(charCode >>> 8);
                }
            };
            return CompactBinaryProtocolWriter;
        }());
        Bond.CompactBinaryProtocolWriter = CompactBinaryProtocolWriter;
        var CompactBinaryProtocolReader = (function () {
            function CompactBinaryProtocolReader() {
            }
            return CompactBinaryProtocolReader;
        }());
        Bond.CompactBinaryProtocolReader = CompactBinaryProtocolReader;
    })(Bond = Microsoft.Bond || (Microsoft.Bond = {}));
})(Microsoft || (Microsoft = {}));
;
var sct;
(function (sct) {
    var Utils = (function () {
        function Utils() {
        }
        Utils.IsSafari = function () {
            if (Utils._isSafari === null) {
                Utils._DetectBrowser();
            }
            return Utils._isSafari;
        };
        //
        // options: {
        //      type:   "GET" or "POST",
        //      url:
        //      headers: {
        //          key1: value1
        //          key2: value2
        //      },
        //      complete: function(xhr)
        // }
        //
        Utils.ajax = function (options) {
            var conn = Utils._createConnection();
            if (options.headers) {
                var params = "qsp=true";
                for (var key in options.headers) {
                    params += "&";
                    params += encodeURIComponent(key);
                    params += "=";
                    params += encodeURIComponent(options.headers[key]);
                }
                if (options.url.indexOf("?") < 0) {
                    options.url += "?";
                }
                else {
                    options.url += "&";
                }
                options.url += params;
            }
            conn.open(options.type, options.url);
            if (options.complete) {
                conn.onload = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 200;
                    }
                    options.complete(conn);
                };
                conn.ontimeout = function () {
                    if (typeof conn.status == "undefined") {
                        conn.status = 500;
                    }
                    options.complete(conn);
                };
                conn.onerror = function () {
                    options.complete(conn);
                };
            }
            conn.send(options.data);
        };
        // This is a workaround for IE8. That it does not support
        // Object.keys.
        Utils.keys = function (dict) {
            if (Object.keys) {
                return Object.keys(dict);
            }
            else {
                var keys = [];
                for (var eachKey in dict) {
                    if (dict.hasOwnProperty(eachKey)) {
                        keys.push(eachKey);
                    }
                }
                return keys;
            }
        };
        Utils.IsUsingXDomainRequest = function () {
            if (Utils._usingXDomainRequest == null) {
                var conn = new XMLHttpRequest();
                if (typeof conn.withCredentials == "undefined" &&
                    typeof XDomainRequest != "undefined") {
                    Utils._usingXDomainRequest = true;
                }
                else {
                    Utils._usingXDomainRequest = false;
                }
            }
            return Utils._usingXDomainRequest;
        };
        Utils._createConnection = function () {
            // for all browsers create standard XMLHttpRequest();
            var conn = new XMLHttpRequest();
            if (Utils.IsUsingXDomainRequest()) {
                // this is IE8/IE9, we should use XDomainRequest to support cross domain
                return new XDomainRequest();
            }
            return conn;
        };
        Utils._DetectBrowser = function () {
            var ua = navigator.userAgent.toLowerCase();
            if (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0) {
                Utils._isSafari = true;
            }
            else {
                Utils._isSafari = false;
            }
        };
        return Utils;
    }());
    Utils._isSafari = null;
    Utils._usingXDomainRequest = null;
    sct.Utils = Utils;
})(sct || (sct = {}));
;
//------------------------------------------------------------------------------
//     This code was generated by using the bondc tool and modified to remove
//      deserialization because it is unused.
// 
//     Tool     : bondc, Version=3.0.1, Build=bond-git.debug.not
//     Template : Microsoft.Bond.Rules.dll#TypeScript.tt
//     File     : DataPackage.ts
//
//     Changes to this file may cause incorrect behavior and will be lost when
//     the code is regenerated.
//------------------------------------------------------------------------------
var microsoft;
(function (microsoft) {
    var applications;
    (function (applications) {
        var telemetry;
        (function (telemetry) {
            var datamodels;
            (function (datamodels) {
                var utils = (function () {
                    function utils() {
                    }
                    utils.GetGuid = function () {
                        var rd = function () {
                            return Math.floor((1 + Math.random()) * 0x10000)
                                .toString(16).substring(1, 5);
                        };
                        return [rd(), rd(), '-', rd(), '-', rd(), '-', rd(), '-', rd(), rd(), rd()].join("");
                    };
                    utils.GetTimeStamp = function () {
                        var val = new Date().getTime();
                        var timestamp = new Microsoft.Bond.Int64("0");
                        timestamp.low = val & 0xffffffff;
                        timestamp.high = Math.floor(val / 0x100000000);
                        return timestamp;
                    };
                    utils.GetTimeStampWithValue = function (timestamp) {
                        var bond_timestamp = new Microsoft.Bond.Int64("0");
                        bond_timestamp.low = timestamp & 0xffffffff;
                        bond_timestamp.high = Math.floor(timestamp / 0x100000000);
                        return bond_timestamp;
                    };
                    return utils;
                }());
                datamodels.utils = utils;
                var RecordType;
                (function (RecordType) {
                    RecordType[RecordType["NotSet"] = 0] = "NotSet";
                    RecordType[RecordType["Event"] = 1] = "Event";
                    // Deprecated, please use PerformanceCounterAzure and PerformanceCounterGfs instead
                    RecordType[RecordType["PerformanceCounter"] = 2] = "PerformanceCounter";
                    RecordType[RecordType["Anomaly"] = 3] = "Anomaly";
                    RecordType[RecordType["Prediction"] = 4] = "Prediction";
                    RecordType[RecordType["TraceLog"] = 5] = "TraceLog";
                    RecordType[RecordType["EventSourceLog"] = 6] = "EventSourceLog";
                    RecordType[RecordType["HttpLog"] = 7] = "HttpLog";
                    RecordType[RecordType["PerformanceCounterAzure"] = 8] = "PerformanceCounterAzure";
                    RecordType[RecordType["PerformanceCounterGfs"] = 9] = "PerformanceCounterGfs";
                })(RecordType = datamodels.RecordType || (datamodels.RecordType = {}));
                var PIIScrubber;
                (function (PIIScrubber) {
                    PIIScrubber[PIIScrubber["NotSet"] = 0] = "NotSet";
                    PIIScrubber[PIIScrubber["O365"] = 1] = "O365";
                    PIIScrubber[PIIScrubber["SkypeBI"] = 2] = "SkypeBI";
                    PIIScrubber[PIIScrubber["SkypeData"] = 3] = "SkypeData";
                })(PIIScrubber = datamodels.PIIScrubber || (datamodels.PIIScrubber = {}));
                var PIIKind;
                (function (PIIKind) {
                    PIIKind[PIIKind["NotSet"] = 0] = "NotSet";
                    PIIKind[PIIKind["DistinguishedName"] = 1] = "DistinguishedName";
                    PIIKind[PIIKind["GenericData"] = 2] = "GenericData";
                    PIIKind[PIIKind["IPV4Address"] = 3] = "IPV4Address";
                    PIIKind[PIIKind["IPv6Address"] = 4] = "IPv6Address";
                    PIIKind[PIIKind["MailSubject"] = 5] = "MailSubject";
                    PIIKind[PIIKind["PhoneNumber"] = 6] = "PhoneNumber";
                    PIIKind[PIIKind["QueryString"] = 7] = "QueryString";
                    PIIKind[PIIKind["SipAddress"] = 8] = "SipAddress";
                    PIIKind[PIIKind["SmtpAddress"] = 9] = "SmtpAddress";
                    PIIKind[PIIKind["Identity"] = 10] = "Identity";
                    PIIKind[PIIKind["Uri"] = 11] = "Uri";
                    PIIKind[PIIKind["Fqdn"] = 12] = "Fqdn";
                    // Supports scrubbing of the last octet in a IPV4 address. E.g. 10.121.227.147 becomes 10.121.227.*
                    PIIKind[PIIKind["IPV4AddressLegacy"] = 13] = "IPV4AddressLegacy";
                })(PIIKind = datamodels.PIIKind || (datamodels.PIIKind = {}));
                var PII = (function () {
                    function PII() {
                        // 1: optional PIIScrubber ScrubType
                        this.ScrubType = telemetry.datamodels.PIIScrubber.NotSet;
                        // 2: optional PIIKind Kind
                        this.Kind = telemetry.datamodels.PIIKind.NotSet;
                        // 3: optional string RawContent
                        this.RawContent = "";
                    }
                    PII.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    PII.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.ScrubType != telemetry.datamodels.PIIScrubber.NotSet) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 1, null);
                            writer.WriteInt32(this.ScrubType);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 1, null);
                        }
                        if (this.Kind != telemetry.datamodels.PIIKind.NotSet) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                            writer.WriteInt32(this.Kind);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                        }
                        if (this.RawContent != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 3, null);
                            writer.WriteString(this.RawContent);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 3, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    PII.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    PII.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return PII;
                }());
                datamodels.PII = PII;
                var Record = (function () {
                    function Record() {
                        // 1: optional string Id
                        this.Id = utils.GetGuid();
                        // 3: optional int64 Timestamp
                        this.Timestamp = utils.GetTimeStamp();
                        // 5: optional string Type
                        this.Type = "";
                        // 6: optional string EventType
                        this.EventType = "";
                        // 13: optional map<string, string> Extension
                        this.Extension = new Microsoft.Bond.Collections.Map();
                        // 24: optional RecordType RecordType
                        this.RecordType = telemetry.datamodels.RecordType.NotSet;
                        // 30: optional map<string, PII> PIIExtensions
                        this.PIIExtensions = new Microsoft.Bond.Collections.Map();
                    }
                    Record.prototype.AddOrReplacePII = function (key, piiValue, piiKind) {
                        var pii = new telemetry.datamodels.PII();
                        pii.RawContent = piiValue;
                        pii.Kind = piiKind;
                        pii.ScrubType = telemetry.datamodels.PIIScrubber.O365;
                        this.PIIExtensions.AddOrReplace(key, pii);
                    };
                    Record.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    Record.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.Id != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 1, null);
                            writer.WriteString(this.Id);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 1, null);
                        }
                        if (!this.Timestamp.Equals("0")) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT64, 3, null);
                            writer.WriteInt64(this.Timestamp);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT64, 3, null);
                        }
                        if (this.Type != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                            writer.WriteString(this.Type);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                        }
                        if (this.EventType != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 6, null);
                            writer.WriteString(this.EventType);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 6, null);
                        }
                        if (this.Extension.Count()) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_MAP, 13, null);
                            writer.WriteMapContainerBegin(this.Extension.Count(), Microsoft.Bond.BondDataType.BT_STRING, Microsoft.Bond.BondDataType.BT_STRING);
                            for (var i8 = 0; i8 < this.Extension.GetBuffer().length; ++i8) {
                                writer.WriteString(this.Extension.GetBuffer()[i8].Key);
                                writer.WriteString(this.Extension.GetBuffer()[i8].Value);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_MAP, 13, null);
                        }
                        if (this.RecordType != telemetry.datamodels.RecordType.NotSet) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 24, null);
                            writer.WriteInt32(this.RecordType);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 24, null);
                        }
                        if (this.PIIExtensions.Count()) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_MAP, 30, null);
                            writer.WriteMapContainerBegin(this.PIIExtensions.Count(), Microsoft.Bond.BondDataType.BT_STRING, Microsoft.Bond.BondDataType.BT_STRUCT);
                            for (var i66 = 0; i66 < this.PIIExtensions.GetBuffer().length; ++i66) {
                                writer.WriteString(this.PIIExtensions.GetBuffer()[i66].Key);
                                this.PIIExtensions.GetBuffer()[i66].Value.WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_MAP, 30, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    Record.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    Record.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return Record;
                }());
                datamodels.Record = Record;
                var DataPackage = (function () {
                    function DataPackage() {
                        // 2: optional string Source
                        this.Source = "";
                        // 5: optional string DataPackageId
                        this.DataPackageId = "";
                        // 6: optional int64 Timestamp
                        this.Timestamp = new Microsoft.Bond.Int64("0");
                        // 8: optional vector<clienttelemetry.data.v1.Record> Records
                        this.Records = [];
                    }
                    DataPackage.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    DataPackage.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.Source != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 2, null);
                            writer.WriteString(this.Source);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 2, null);
                        }
                        if (this.DataPackageId != "") {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                            writer.WriteString(this.DataPackageId);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_STRING, 5, null);
                        }
                        if (!this.Timestamp.Equals("0")) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT64, 6, null);
                            writer.WriteInt64(this.Timestamp);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT64, 6, null);
                        }
                        if (this.Records.length) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_LIST, 8, null);
                            writer.WriteContainerBegin(this.Records.length, Microsoft.Bond.BondDataType.BT_STRUCT);
                            for (var i52 = 0; i52 < this.Records.length; ++i52) {
                                this.Records[i52].WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_LIST, 8, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    DataPackage.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    DataPackage.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return DataPackage;
                }());
                datamodels.DataPackage = DataPackage;
                var ClientToCollectorRequest = (function () {
                    function ClientToCollectorRequest() {
                        // 1: optional vector<clienttelemetry.data.v1.DataPackage> DataPackages
                        this.DataPackages = [];
                        // 2: optional int32 RequestRetryCount
                        this.RequestRetryCount = 0;
                    }
                    ClientToCollectorRequest.prototype.Write = function (writer) {
                        this.WriteImpl(writer, false /*isBase*/);
                    };
                    ClientToCollectorRequest.prototype.WriteImpl = function (writer, isBase) {
                        writer.WriteStructBegin(null /*metadata*/, isBase);
                        if (this.DataPackages.length) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_LIST, 1, null);
                            writer.WriteContainerBegin(this.DataPackages.length, Microsoft.Bond.BondDataType.BT_STRUCT);
                            for (var i67 = 0; i67 < this.DataPackages.length; ++i67) {
                                this.DataPackages[i67].WriteImpl(writer, false);
                            }
                            writer.WriteContainerEnd();
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_LIST, 1, null);
                        }
                        if (this.RequestRetryCount != 0) {
                            writer.WriteFieldBegin(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                            writer.WriteInt32(this.RequestRetryCount);
                            writer.WriteFieldEnd();
                        }
                        else {
                            writer.WriteFieldOmitted(Microsoft.Bond.BondDataType.BT_INT32, 2, null);
                        }
                        writer.WriteStructEnd(isBase);
                    };
                    ClientToCollectorRequest.prototype.Read = function (reader) {
                        this.ReadImpl(reader, false /*isBase*/);
                    };
                    ClientToCollectorRequest.prototype.ReadImpl = function (reader, isBase) {
                    };
                    return ClientToCollectorRequest;
                }());
                datamodels.ClientToCollectorRequest = ClientToCollectorRequest;
            })(datamodels = telemetry.datamodels || (telemetry.datamodels = {}));
        })(telemetry = applications.telemetry || (applications.telemetry = {}));
    })(applications = microsoft.applications || (microsoft.applications = {}));
})(microsoft || (microsoft = {}));
;
/** \file clienttelemetry.ts
    This filed defined the _sender class.

    \author yuboxie
    \date 2013-12
*/
//TODO(abpanwar): rename files to better match the inner module
var microsoft;
(function (microsoft) {
    var applications;
    (function (applications) {
        var telemetry;
        (function (telemetry) {
            var _sender;
            (function (_sender) {
                var CallbackEventType;
                (function (CallbackEventType) {
                    CallbackEventType[CallbackEventType["SENT"] = 0] = "SENT";
                    CallbackEventType[CallbackEventType["SEND_FAILED"] = 1] = "SEND_FAILED";
                })(CallbackEventType = _sender.CallbackEventType || (_sender.CallbackEventType = {}));
                var DATARV_ERROR;
                (function (DATARV_ERROR) {
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_OK"] = 0] = "DATARV_ERROR_OK";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_EVENT"] = 1] = "DATARV_ERROR_INVALID_EVENT";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_CONFIG"] = 2] = "DATARV_ERROR_INVALID_CONFIG";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_DEPENDENCIES"] = 3] = "DATARV_ERROR_INVALID_DEPENDENCIES";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_STATUS"] = 4] = "DATARV_ERROR_INVALID_STATUS";
                    DATARV_ERROR[DATARV_ERROR["DATARV_ERROR_INVALID_ARG"] = 5] = "DATARV_ERROR_INVALID_ARG";
                })(DATARV_ERROR = _sender.DATARV_ERROR || (_sender.DATARV_ERROR = {}));
                var Exception = (function () {
                    function Exception(errorCode) {
                        this._errorCode = DATARV_ERROR.DATARV_ERROR_OK;
                        this._errorCode = errorCode;
                    }
                    Exception.prototype.ErrorCode = function () {
                        return this._errorCode;
                    };
                    Exception.prototype.toString = function () {
                        switch (this._errorCode) {
                            case DATARV_ERROR.DATARV_ERROR_OK:
                                return "DATARV_ERROR_OK";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_EVENT:
                                return "Event is invalid. Either event.Id is empty, or event.Timestamp is empty, or event.EventType is empty.";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_CONFIG:
                                return "Invalid configuration. CollectorUrl is missing.";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_DEPENDENCIES:
                                return "DATARV_ERROR_INVALID_DEPENDENCIES";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_STATUS:
                                return "Telemetry Manager is not initialized.";
                            case DATARV_ERROR.DATARV_ERROR_INVALID_ARG:
                                return "TenantToken is null or empty, or events is null.";
                            default:
                                return "Unknown error";
                        }
                    };
                    return Exception;
                }());
                _sender.Exception = Exception;
                /** TelemetryConfig of TelemetryManager.
        
            \note
            TelemetryManager will hold the reference of this config. After you invoke
            Initialize(), you should never modify any content of this config object.
            Otherwise, the behavior is undefined.
        */
                var TelemetryConfig = (function () {
                    function TelemetryConfig() {
                    }
                    return TelemetryConfig;
                }());
                _sender.TelemetryConfig = TelemetryConfig;
                var TelemetryManagerFactory = (function () {
                    function TelemetryManagerFactory() {
                    }
                    TelemetryManagerFactory.CreateTelemetryManager = function () {
                        return new TelemetryManagerImpl();
                    };
                    return TelemetryManagerFactory;
                }());
                _sender.TelemetryManagerFactory = TelemetryManagerFactory;
                //
                // const
                //
                var Consts = (function () {
                    function Consts() {
                    }
                    Consts.MaxPackageSizeInBytes = function () { return 3 * 1000 * 1000; }; // less than 3MB
                    Consts.TimeIntervalForNextSendInMS = function () { return 15 * 1000; }; // send 2 seconds every time
                    return Consts;
                }());
                ;
                //
                // Impl
                //
                /** TelemetryManager status.
        
           \note
           The status order is very important, don't modify it unless you know what you are doing.
        */
                var TelemetryManagerStatus;
                (function (TelemetryManagerStatus) {
                    TelemetryManagerStatus[TelemetryManagerStatus["Created"] = 0] = "Created";
                    TelemetryManagerStatus[TelemetryManagerStatus["Initialized"] = 1] = "Initialized";
                    TelemetryManagerStatus[TelemetryManagerStatus["Started"] = 2] = "Started";
                })(TelemetryManagerStatus || (TelemetryManagerStatus = {}));
                var TelemetryManagerImpl = (function () {
                    function TelemetryManagerImpl() {
                        this._MaxPackageSizeInBytes = Consts.MaxPackageSizeInBytes();
                        this._listeners = [];
                        this._status = TelemetryManagerStatus.Created;
                        this._ecsClient = null;
                        this._etag = null;
                        this._ecsCallback = null;
                        this._testServerResponseHook = null;
                        /******* TEST_INJECTION_END *********/
                    }
                    TelemetryManagerImpl.prototype.Initialize = function (config) {
                        if (this._status != TelemetryManagerStatus.Created) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        if (!config ||
                            !config.collectorUrl) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_CONFIG);
                        }
                        this._config = config;
                        this._Reset();
                        this._status = TelemetryManagerStatus.Initialized;
                        if (config.ecsClient) {
                            this._Verbose("ECS object assigned. Do integration");
                            this._ecsClient = config.ecsClient;
                        }
                        this._Verbose("Initialize() done");
                    };
                    TelemetryManagerImpl.prototype.AddListener = function (func) {
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "AddListener(), status: ", this._status,
                            " old length: ", this._listeners.length,
                            " func: ", func
                        ].join(""));
                        for (var i = 0; i < this._listeners.length; ++i) {
                            if (this._listeners[i] == func) {
                                this._Verbose("the listener has been added already, index: " + i);
                                return;
                            }
                        }
                        this._listeners.push(func);
                        this._Verbose("AddListener() done, the new length: " + this._listeners.length);
                    };
                    TelemetryManagerImpl.prototype.RemoveListener = function (func) {
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "RemoveListener(), status: ", this._status,
                            " old length: ", this._listeners.length,
                            " func: ", func
                        ].join(""));
                        for (var i = 0; i < this._listeners.length; ++i) {
                            if (this._listeners[i] == func) {
                                if (this._listeners.length == 1) {
                                    this._listeners = [];
                                }
                                else if (i == this._listeners.length - 1) {
                                    this._listeners.pop();
                                }
                                else {
                                    this._listeners[i] = this._listeners.pop();
                                }
                                this._Verbose([
                                    "this listener has been found, index: ", i,
                                    "new length: ", this._listeners.length
                                ].join(""));
                                return;
                            }
                        }
                        this._Verbose("listener isn't been found, new length" + this._listeners.length);
                    };
                    TelemetryManagerImpl.prototype.Start = function () {
                        // If it hasn't been initialized, throw exception.
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "Start(), status:", this._status,
                            "tag:", TelemetryManagerImpl._tag
                        ].join(" "));
                        if (this._status >= TelemetryManagerStatus.Started) {
                            this._Verbose("Start() already, ignore");
                        }
                        if (this._ecsClient) {
                            this._ecsCallback = this._CreateEcsCallback();
                            this._ecsClient.AddListener(this._ecsCallback);
                            this._etag = this._ecsClient.GetETag();
                        }
                        // change the status to started.
                        ++TelemetryManagerImpl._tag;
                        this._status = TelemetryManagerStatus.Started;
                        this._Verbose([
                            "Start() done, status: ", this._status,
                            "tag: ", TelemetryManagerImpl._tag
                        ].join(""));
                    };
                    TelemetryManagerImpl.prototype.Stop = function () {
                        // If it hasn't been initialized, throw exception.
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose("Stop(), status: " + this._status);
                        if (this._status == TelemetryManagerStatus.Initialized) {
                            this._Verbose("Stop() already, ignore");
                            return;
                        }
                        //
                        // do stop work
                        //
                        // 1. cleanup states
                        this._Reset();
                        // 2. reset status to initailzied
                        this._status = TelemetryManagerStatus.Initialized;
                        this._Verbose("Stop() done, status: " + this._status);
                    };
                    TelemetryManagerImpl.prototype.Flush = function (func) {
                        if (!this._eventsCache.IsEmpty()) {
                            this._WorkThread(func);
                        }
                    };
                    TelemetryManagerImpl.prototype.SendAsync = function (tenantToken, events) {
                        if (this._status < TelemetryManagerStatus.Initialized) {
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_STATUS);
                        }
                        this._Verbose([
                            "SendAsync(), status:", this._status,
                            "tenantToken:", tenantToken,
                            "count:", events.length
                        ].join(" "));
                        if (this._status < TelemetryManagerStatus.Started) {
                            this._Info("SendAsync(), not started, ignore, return false");
                            return false;
                        }
                        // check the input parameters
                        if (!tenantToken || !events) {
                            this._Error("SendAsync(), tenantToken or events is null or empty");
                            throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_ARG);
                        }
                        // check all events are valid, add missed fields.
                        for (var i = 0; i < events.length; ++i) {
                            if (!events[i].Id ||
                                !TelemetryManagerImpl._eventTypeRegex.test(events[i].EventType) ||
                                events[i].Timestamp.Equals("0")) {
                                this._Error([
                                    "eventId:", events[i].Id,
                                    "eventType:", events[i].EventType,
                                    "timestamp high:", events[i].Timestamp.high,
                                    "timestamp low:", events[i].Timestamp.low
                                ].join(""));
                                throw new Exception(DATARV_ERROR.DATARV_ERROR_INVALID_EVENT);
                            }
                        }
                        // put all events in events queue
                        this._eventsCache.AddEvents(tenantToken, events);
                        this._Verbose([
                            "SendAsync(), currentTimer: ", this._timer,
                            "eventsCacheIsEmpty", this._eventsCache.IsEmpty()
                        ].join(" "));
                        // if the events queue are not empty, and we haven't schedule the send
                        // action, schedule it at once.
                        // Don't invoke _WorkThread() directly, otherwise, it may block UI.
                        if (!this._eventsCache.IsEmpty() && !this._timer) {
                            this._ScheduleTimer(false /*isRetry*/);
                        }
                        this._Verbose("SendAsync() done");
                        return true;
                    };
                    TelemetryManagerImpl.prototype._WorkThread = function (flushCallback) {
                        var _this = this;
                        try {
                            var workThreadStartTime = Date.now();
                            this._Verbose("_WorkThread, status: " + this._status);
                            if (this._status < TelemetryManagerStatus.Started) {
                                this._Verbose("_WorkThread, status is not started, return");
                                return;
                            }
                            // dequeue one tenants events
                            var item = this._eventsCache.DequeuEvents();
                            if (item == null) {
                                this._Verbose("_WorkThread, No events found, return");
                                // no more events need process, so clear the timer and return
                                this._CleanTimer();
                                return;
                            }
                            var totalEvents = item.events.length;
                            // pack the events and send
                            var result = this._PackEvents(item.tenantToken, item.events);
                            // add unsend events back to the queue
                            this._eventsCache.AddEvents(item.tenantToken, result.remainedEvents);
                            var remainingEvents = result.remainedEvents.length;
                            // check if there is anything packed
                            if (result.buffer == null || result.buffer.length == 0) {
                                // schedule for next check if necessary
                                if (!this._eventsCache.IsEmpty()) {
                                    this._Verbose("eventsCache is not empty, schedule for next run");
                                    this._ScheduleTimer(false /*isRetry*/);
                                }
                                else {
                                    this._Verbose("eventsCache is empty, stop schedule");
                                    this._CleanTimer();
                                }
                                return;
                            }
                            if (this._testServerResponseHook) {
                                //Using setTimeout with 100 ms to simulate the network time to and fro from the collector and calling _SendCallback asynchronously
                                var xhr = this._testServerResponseHook();
                                setTimeout(this._SendCallback(tag, item.tenantToken, result.sendEvents, xhr, null), 100);
                                return;
                            }
                            var postParams = {
                                type: "POST",
                                url: this._config.collectorUrl,
                                processData: false,
                                headers: {
                                    "content-type": "application/bond-compact-binary",
                                    "client-id": "NO_AUTH",
                                    "sdk-version": "ACT-Web-JS-" + clienttelemetry_build.version
                                },
                                complete: function (xhr) { return _this._SendCallback(tag, item.tenantToken, result.sendEvents, xhr, flushCallback); }
                            };
                            if (sct.Utils.IsSafari() || typeof Uint8Array == "undefined") {
                                this._Verbose("Uint8Array is undefined, send with base64 encode.");
                                postParams["data"] = Microsoft.Bond.Encoding.Base64.GetString(result.buffer);
                                postParams["headers"]["content-encoding"] = "base64";
                            }
                            else {
                                this._Verbose("Uint8Array is defined, send with binary format directly.");
                                postParams["data"] = new Uint8Array(result.buffer);
                            }
                            if (item.tenantToken) {
                                postParams["headers"]["x-apikey"] = item.tenantToken;
                            }
                            // send it via jquery
                            var tag = TelemetryManagerImpl._tag;
                            this._lastActiveTime = new Date().getTime();
                            sct.Utils.ajax(postParams);
                            this._Verbose("_Workthread, send via jquery, tag: " + tag);
                            this._Info('Processing telemetry events took ' + (Date.now() - workThreadStartTime) + ' ms for ' + (totalEvents - remainingEvents) + ' events with total size of ' + result.buffer.length + ' bytes, remaining events - ' + remainingEvents);
                        }
                        catch (ex) {
                            this._Error("_WorkThread, exception: " + ex);
                        }
                    };
                    /** Package all events to a package.
        
                return value is json object:
                {
                    buffer: bond serialize buffer (binary data),
                    sendEvents: the events are packaged.
                },
        
                events contains unpackaged events.
            */
                    TelemetryManagerImpl.prototype._PackEvents = function (tenantToken, events) {
                        this._Verbose("_PackageEvents, total Count: " + events.length);
                        // create the client to collector request
                        var collectorRequest = new telemetry.datamodels.ClientToCollectorRequest();
                        // create the data package
                        var pkg = new telemetry.datamodels.DataPackage();
                        pkg.Source = "JS_default_source";
                        pkg.DataPackageId = telemetry.datamodels.utils.GetGuid();
                        pkg.Timestamp = telemetry.datamodels.utils.GetTimeStamp();
                        // first, try to send all events
                        var buffer;
                        var sendEvents = events;
                        events = [];
                        // TODO (amitap) this is added code to aria sdk
                        // do not even try to send more than 200 events, this is to reduce number of serializations which can cause perf regression
                        // 200 events are approximately 400kb
                        if (sendEvents.length > 200) {
                            var eventsPart1 = sendEvents.splice(0, 200);
                            events.push.apply(events, sendEvents);
                            sendEvents = eventsPart1;
                        }
                        while (true) {
                            pkg.Records = [];
                            pkg.Records.push.apply(pkg.Records, sendEvents);
                            collectorRequest.DataPackages = [];
                            collectorRequest.DataPackages.push(pkg);
                            buffer = this._Serialize(collectorRequest);
                            this._Verbose([
                                "_PackageEvents, sendEvents.length:", sendEvents.length,
                                " buffer.length:", buffer.length,
                                " MaxPackageSize:", this._MaxPackageSizeInBytes
                            ].join(""));
                            if (buffer.length < this._MaxPackageSizeInBytes) {
                                break;
                            }
                            else if (sendEvents.length == 1) {
                                //single record larger than max package size, drop
                                sendEvents = [];
                                buffer = null;
                                break;
                            }
                            // too large, we must reduce it.
                            var tmp = sendEvents.splice(0, Math.floor(sendEvents.length / 2));
                            this._Verbose("_PackageEvents, too large, package again");
                            // add the rest events back to events;
                            events.push.apply(events, sendEvents);
                            sendEvents = tmp;
                        }
                        this._Verbose([
                            "_PakcageEvents done, sendEventsCount:", sendEvents.length,
                            "buffer.length:", buffer == null ? 0 : buffer.length,
                            "remained events:", events.length
                        ].join(""));
                        return { buffer: buffer, sendEvents: sendEvents, remainedEvents: events };
                    };
                    TelemetryManagerImpl.prototype._Serialize = function (collectorRequest) {
                        var stream = new Microsoft.Bond.IO.MemoryStream();
                        var writer = new Microsoft.Bond.CompactBinaryProtocolWriter(stream);
                        collectorRequest.Write(writer);
                        return stream.GetBuffer();
                    };
                    /** This function will handle the callback from ajax    */
                    TelemetryManagerImpl.prototype._SendCallback = function (tag, tenantToken, events, jqXHR, flushCallback) {
                        this._Verbose([
                            "_SendCallback",
                            "tag:", tag,
                            "current tag:", TelemetryManagerImpl._tag,
                            "tenantToken:", tenantToken,
                            "events count:", events.length,
                            "jqXHR:", jqXHR
                        ].join(""));
                        //Do the flush callback. Since this sending was scheduled synchronously don't schedule timer
                        //again for async sending.
                        if (flushCallback != null) {
                            flushCallback((jqXHR ? jqXHR.status : 0), tenantToken, events);
                            return;
                        }
                        var isSuccess = jqXHR != null && jqXHR.status >= 200 && jqXHR.status < 300;
                        // if the status is not sending (user may invoke Stop()), do nothing
                        if (this._status < TelemetryManagerStatus.Started ||
                            tag < TelemetryManagerImpl._tag) {
                            this._Verbose("_SendCallback, is not started, or tag is not the same, return");
                            return;
                        }
                        // if need retry, put the events back to the events queue and
                        // try it later. 400 means the data format is not correct, so
                        // don't retry for this case.
                        //
                        // for IE 8/IE 9, there is no way to get the status code, don't retry also.
                        // amitap - status 0 can mean offlie so we want to retry
                        if (!isSuccess && (!jqXHR || jqXHR.status != 400)) {
                            this._Verbose("retry statusCode: " + (jqXHR ? jqXHR.status : 0));
                            this._eventsCache.AddEvents(tenantToken, events);
                            this._ScheduleTimer(true /*isRetry*/);
                            return;
                        }
                        // callback to notify user send success.
                        for (var i = 0; i < this._listeners.length; ++i) {
                            this._listeners[i](isSuccess ? CallbackEventType.SENT : CallbackEventType.SEND_FAILED, (jqXHR ? jqXHR.status : 0), tenantToken, events);
                        }
                        // schedule for next check if necessary
                        if (!this._eventsCache.IsEmpty()) {
                            this._Verbose("eventsCache is not empty, schedule for next run");
                            this._ScheduleTimer(false /*isRetry*/);
                        }
                        else {
                            this._Verbose("eventsCache is empty, stop schedule");
                            this._CleanTimer();
                        }
                    };
                    TelemetryManagerImpl.prototype._CleanTimer = function () {
                        this._Verbose("_CleanTimer(), timer: " + this._timer);
                        if (this._timer) {
                            clearTimeout(this._timer);
                            this._timer = null;
                        }
                    };
                    /** Schedule Retry.
        
                This function will schedule re-try after X seconds. X value is determined
                by the following algorithm:
                1. for the 1st, X is a random value between 5~10 (5*2^0~5*2^1).
                2. for the 2nd, X is a random value between 10~20 (5*2^1~5*2^2).
                3. for the 3rd, X is a random value between 20~40 (5*2^2~5*2^3).
                4. for the 4th, X is a random value between 40~80 (5*2^3~5*2^4).
                5. for the 5th, X is a random value between 80~160 (5*2^4~5*2^5).
                6. for the 6th, X is a random value between 160~320 (5*2^5~5*2^6).
                7. Go back to 1.
            */
                    TelemetryManagerImpl.prototype._ScheduleTimer = function (isRetry) {
                        var _this = this;
                        this._Verbose("_ScheduleTimer: isRetry: " + isRetry);
                        // clear previous timer always.
                        this._CleanTimer();
                        if (!isRetry) {
                            // next send will be in at least 1 second later
                            var X = 0;
                            var now = new Date().getTime();
                            var late = now - this._lastActiveTime;
                            if (late > Consts.TimeIntervalForNextSendInMS()) {
                                // we haven't scheduled in last 1 second, so schedule it at once.
                                X = 0;
                            }
                            else {
                                X = Consts.TimeIntervalForNextSendInMS() - late;
                            }
                            this._timer = setTimeout(function () { return _this._WorkThread(null); }, X);
                            this._Verbose("_ScheduleTimer, next try: " + X);
                            this._rescheduleFactor = 1;
                        }
                        else {
                            // retry
                            this._Verbose("_ScheduleTimer, current factor: " + this._rescheduleFactor);
                            var X = Math.floor(5 * this._rescheduleFactor * (1 + Math.random()));
                            this._timer = setTimeout(function () { return _this._WorkThread(null); }, X * 1000);
                            this._Verbose("_ScheduleTimer, next try (s): " + X);
                            this._rescheduleFactor <<= 1;
                            if (this._rescheduleFactor > 64) {
                                this._rescheduleFactor = 1;
                            }
                        }
                    };
                    //
                    // Log functions
                    //
                    TelemetryManagerImpl.prototype._Verbose = function (msg) {
                        if (this._config.log) {
                            this._config.log.Verbose("[TelemetryManagerImpl]: " + msg);
                        }
                    };
                    TelemetryManagerImpl.prototype._Info = function (msg) {
                        if (this._config.log) {
                            this._config.log.Info("[TelemetryManagerImpl]: " + msg);
                        }
                    };
                    TelemetryManagerImpl.prototype._Error = function (msg) {
                        if (this._config.log) {
                            this._config.log.Error("[TelemetryManagerImpl]: " + msg);
                        }
                    };
                    /** Clean all stats without listener queue */
                    TelemetryManagerImpl.prototype._Reset = function () {
                        this._Verbose("Reset()");
                        this._CleanTimer();
                        this._lastActiveTime = 0;
                        this._rescheduleFactor = 1;
                        this._sendingEvents = [];
                        this._eventsCache = new TelemetryEventCache();
                        // 3. Shutdown listener
                        if (this._ecsClient) {
                            this._ecsClient.RemoveListener(this._ecsCallback);
                            this._ecsCallback = null;
                        }
                    };
                    TelemetryManagerImpl.prototype._CreateEcsCallback = function () {
                        var _this = this;
                        return function (status) {
                            if (status == ecs.CallbackEventType.CONFIG_UPDATED) {
                                // Use number as status to avoid dependency.
                                _this._etag = _this._ecsClient.GetETag();
                            }
                        };
                    };
                    /******* TEST_INJECTION_START *******/
                    TelemetryManagerImpl.prototype.__GetListenerArray = function () {
                        return this._listeners;
                    };
                    TelemetryManagerImpl.prototype.__GetTotalEventsCount = function () {
                        return this._eventsCache.GetTotalEventsCount();
                    };
                    TelemetryManagerImpl.prototype.__IsScheduled = function () {
                        return this._timer != null;
                    };
                    TelemetryManagerImpl.prototype.__ChageMaxPackageSizeInKB = function (size) {
                        this._MaxPackageSizeInBytes = size * 1024;
                    };
                    TelemetryManagerImpl.prototype.__SetTestServerResponseHook = function (callback) {
                        this._testServerResponseHook = callback;
                    };
                    return TelemetryManagerImpl;
                }());
                TelemetryManagerImpl._eventTypeRegex = /^[a-zA-Z0-9]([a-zA-Z0-9]|_){2,98}[a-zA-Z0-9]$/;
                TelemetryManagerImpl._tag = 0;
                _sender.TelemetryManagerImpl = TelemetryManagerImpl;
                var TelemetryEventCache = (function () {
                    function TelemetryEventCache() {
                        this._events = {};
                        this._tokens = [];
                    }
                    TelemetryEventCache.prototype.AddEvents = function (tenantToken, events) {
                        if (!events.length) {
                            return;
                        }
                        if (events.length > 10000) {
                            return;
                        }
                        if (!this._events[tenantToken]) {
                            this._events[tenantToken] = [];
                            this._tokens.push(tenantToken);
                        }
                        this._events[tenantToken].push.apply(this._events[tenantToken], events);
                    };
                    TelemetryEventCache.prototype.IsEmpty = function () {
                        return this._tokens.length == 0;
                    };
                    TelemetryEventCache.prototype.DequeuEvents = function () {
                        if (this._tokens.length == 0) {
                            return null;
                        }
                        var tenantToken = this._tokens.shift();
                        var events = this._events[tenantToken];
                        delete this._events[tenantToken];
                        return { tenantToken: tenantToken, events: events };
                    };
                    TelemetryEventCache.prototype.GetTotalEventsCount = function () {
                        var sum = 0;
                        for (var key in this._events) {
                            sum += this._events[key].length;
                        }
                        return sum;
                    };
                    return TelemetryEventCache;
                }());
            })(_sender = telemetry._sender || (telemetry._sender = {}));
        })(telemetry = applications.telemetry || (applications.telemetry = {}));
    })(applications = microsoft.applications || (microsoft.applications = {}));
})(microsoft || (microsoft = {}));
;
var clienttelemetry_build;
(function (clienttelemetry_build) {
    clienttelemetry_build.version = "2.5.0";
})(clienttelemetry_build || (clienttelemetry_build = {}));
;
var microsoft;
(function (microsoft) {
    var applications;
    (function (applications) {
        var telemetry;
        (function (telemetry) {
            telemetry.globalTelemetryManager = null;
            /**
             * Configuration for the ARIA logger.
             */
            var LogConfiguration = (function () {
                function LogConfiguration() {
                    /**
                     *  Set the collector url.
                     */
                    this.collectorUrl = null;
                }
                return LogConfiguration;
            }());
            telemetry.LogConfiguration = LogConfiguration;
            var Property = (function () {
                function Property() {
                    this.key = null;
                    this.value = null;
                    this.pii = null;
                }
                /**
                 * Checks if the pii value is in the datamodels.PIIKind enum
                 */
                Property._isPii = function (pii) {
                    if (pii == (null || undefined || telemetry.datamodels.PIIKind.NotSet)) {
                        return false;
                    }
                    var result = false;
                    for (var val in telemetry.datamodels.PIIKind) {
                        if (!isNaN(val)) {
                            if (val == pii) {
                                result = true;
                            }
                        }
                    }
                    return result;
                };
                return Property;
            }());
            telemetry.Property = Property;
            /**
             * eventProperties class allows adding custom key value pairs, including PII data to events.
             */
            var EventProperties = (function () {
                function EventProperties() {
                    /**
                     * Specify a name for this event. This is required if you send any custom key, value pairs.
                     */
                    this.name = null;
                    /**
                     * Override the timestamp on the event being sent, which is set to the current time by default.
                     */
                    this.timestamp = null;
                    /**
                     * Property bag that can be used to add custom extensions to the logged event.
                     */
                    this.properties = [];
                    /**
                     * Specify a type for this event. The type provided will be prefixed with the string
                     * "Custom.".
                     */
                    this.eventType = null;
                }
                /**
                 * Set a named property and optionally tag it as PII.
                 */
                EventProperties.prototype.setProperty = function (key, value, pii) {
                    if (!key || (!this.properties[key] && !EventProperties._propertyNameRegex.test(key))) {
                        throw new Exception(TelemetryError.INVALID_PROPERTY_NAME);
                    }
                    this.properties[key] = {
                        key: key,
                        value: value,
                        pii: pii != telemetry.datamodels.PIIKind.NotSet ? pii : null
                    };
                };
                return EventProperties;
            }());
            //Regex for JS sdk to allow specifying common fields
            EventProperties._propertyNameRegex = /^[a-zA-Z0-9](([a-zA-Z0-9|_|.]){0,98}[a-zA-Z0-9])?$/;
            telemetry.EventProperties = EventProperties;
            var TelemetryError;
            (function (TelemetryError) {
                TelemetryError[TelemetryError["INVALID_TENANT_TOKEN"] = 1] = "INVALID_TENANT_TOKEN";
                TelemetryError[TelemetryError["MISSING_EVENT_PROPERTIES_NAME"] = 2] = "MISSING_EVENT_PROPERTIES_NAME";
                TelemetryError[TelemetryError["INVALID_PROPERTY_NAME"] = 3] = "INVALID_PROPERTY_NAME";
                TelemetryError[TelemetryError["INVALID_COLLECTOR_URL"] = 4] = "INVALID_COLLECTOR_URL";
                TelemetryError[TelemetryError["MISSING_FAILURE_SIGNATURE"] = 5] = "MISSING_FAILURE_SIGNATURE";
                TelemetryError[TelemetryError["MISSING_FAILURE_DETAIL"] = 6] = "MISSING_FAILURE_DETAIL";
                TelemetryError[TelemetryError["MISSING_PAGEVIEW_ID"] = 7] = "MISSING_PAGEVIEW_ID";
                TelemetryError[TelemetryError["MISSING_PAGEVIEW_NAME"] = 8] = "MISSING_PAGEVIEW_NAME";
                TelemetryError[TelemetryError["INVALID_SESSION_STATE"] = 9] = "INVALID_SESSION_STATE";
            })(TelemetryError = telemetry.TelemetryError || (telemetry.TelemetryError = {}));
            /**
             * Helper class to throw exceptions.
             */
            var Exception = (function () {
                function Exception(errorCode) {
                    this.errorCode = null;
                    this.errorCode = errorCode;
                }
                Exception.prototype.ErrorCode = function () {
                    return this.errorCode;
                };
                Exception.prototype.toString = function () {
                    switch (this.errorCode) {
                        case TelemetryError.INVALID_TENANT_TOKEN:
                            return "Invalid tenant token";
                        case TelemetryError.MISSING_EVENT_PROPERTIES_NAME:
                            return "Eventproperties.name can not be null or empty";
                        case TelemetryError.INVALID_PROPERTY_NAME:
                            return "Invalid Key. Key does not conform to regular expression ^[a-zA-Z0-9](([a-zA-Z0-9|_]){0,98}[a-zA-Z0-9])?$";
                        case TelemetryError.INVALID_COLLECTOR_URL:
                            return "Collector url can't be null or empty.";
                        case TelemetryError.MISSING_FAILURE_SIGNATURE:
                            return "Failure signature can't be null or empty.";
                        case TelemetryError.MISSING_FAILURE_DETAIL:
                            return "Failure detail can't be null or empty.";
                        case TelemetryError.MISSING_PAGEVIEW_ID:
                            return "Pageview id can't be null or empty.";
                        case TelemetryError.MISSING_PAGEVIEW_NAME:
                            return "Pageview name can't be null or empty.";
                        case TelemetryError.INVALID_SESSION_STATE:
                            return "Session state has to be a value from the SessionState enum.";
                        default:
                            return "Unknown error";
                    }
                };
                return Exception;
            }());
            telemetry.Exception = Exception;
            var SemanticContext = (function () {
                function SemanticContext(allowDeviceInfoFields) {
                    this.contextMap = new Microsoft.Bond.Collections.Map();
                    this.piiKind = telemetry.datamodels.PIIKind.NotSet;
                    this._allowDeviceInfoFields = false;
                    this._allowDeviceInfoFields = allowDeviceInfoFields;
                }
                SemanticContext.prototype.setAppId = function (appId) {
                    if (appId) {
                        this.contextMap.Add("AppInfo.Id", appId);
                    }
                };
                SemanticContext.prototype.setAppVersion = function (appVersion) {
                    if (appVersion) {
                        this.contextMap.Add("AppInfo.Version", appVersion);
                    }
                };
                SemanticContext.prototype.setAppLanguage = function (appLanguage) {
                    if (appLanguage) {
                        this.contextMap.Add("AppInfo.Language", appLanguage);
                    }
                };
                SemanticContext.prototype.setDeviceId = function (deviceId) {
                    if (deviceId && this._allowDeviceInfoFields) {
                        this.contextMap.Add("DeviceInfo.Id", deviceId);
                    }
                };
                SemanticContext.prototype.setDeviceOsName = function (deviceOsName) {
                    if (deviceOsName && this._allowDeviceInfoFields) {
                        this.contextMap.Add("DeviceInfo.OsName", deviceOsName);
                    }
                };
                SemanticContext.prototype.setDeviceOsVersion = function (deviceOsVersion) {
                    if (deviceOsVersion && this._allowDeviceInfoFields) {
                        this.contextMap.Add("DeviceInfo.OsVersion", deviceOsVersion);
                    }
                };
                SemanticContext.prototype.setDeviceBrowserName = function (deviceBrowserName) {
                    if (deviceBrowserName && this._allowDeviceInfoFields) {
                        this.contextMap.Add("DeviceInfo.BrowserName", deviceBrowserName);
                    }
                };
                SemanticContext.prototype.setDeviceBrowserVersion = function (deviceBrowserVersion) {
                    if (deviceBrowserVersion && this._allowDeviceInfoFields) {
                        this.contextMap.Add("DeviceInfo.BrowserVersion", deviceBrowserVersion);
                    }
                };
                SemanticContext.prototype.setUserId = function (userId, piiKind) {
                    if (userId) {
                        this.contextMap.Add("UserInfo.Id", userId);
                    }
                    if (Property._isPii(piiKind)) {
                        this.piiKind = piiKind;
                    }
                };
                SemanticContext.prototype.setUserMsaId = function (userMsaId) {
                    if (userMsaId) {
                        this.contextMap.Add("UserInfo.MsaId", userMsaId);
                    }
                };
                SemanticContext.prototype.setUserANID = function (userANID) {
                    if (userANID) {
                        this.contextMap.Add("UserInfo.ANID", userANID);
                    }
                };
                SemanticContext.prototype.setUserAdvertisingId = function (userAdvertisingId) {
                    if (userAdvertisingId) {
                        this.contextMap.Add("UserInfo.AdvertisingId", userAdvertisingId);
                    }
                };
                SemanticContext.prototype.setUserTimeZone = function (userTimeZone) {
                    if (userTimeZone) {
                        this.contextMap.Add("UserInfo.TimeZone", userTimeZone);
                    }
                };
                SemanticContext.prototype.setUserLanguage = function (userLanguage) {
                    if (userLanguage) {
                        this.contextMap.Add("UserInfo.Language", userLanguage);
                    }
                };
                return SemanticContext;
            }());
            telemetry.SemanticContext = SemanticContext;
            var SystemInformation = (function () {
                function SystemInformation() {
                }
                SystemInformation.initialize = function (documentInfo) {
                    // amitap - document and window objects are not supported by web worker
                    SystemInformation.documentInfo = documentInfo;
                    var appLanguage = documentInfo.appLanguage; //document.documentElement.lang;
                    if (appLanguage) {
                        SystemInformation.semanticContext.setAppLanguage(appLanguage);
                    }
                    var userLanguage = documentInfo.userLanguage; //window.navigator.userLanguage || window.navigator.language;
                    if (userLanguage) {
                        SystemInformation.semanticContext.setUserLanguage(userLanguage);
                    }
                    // Format the time zone
                    var timeZone = new Date().getTimezoneOffset();
                    var minutes = timeZone % 60;
                    var hours = (timeZone - minutes) / 60;
                    var timeZonePrefix = "+";
                    if (hours > 0) {
                        timeZonePrefix = "-";
                    }
                    minutes = Math.abs(minutes);
                    hours = Math.abs(hours);
                    var formattedTimeZone = timeZonePrefix + (hours < 10 ? '0' + hours : hours.toString()) + ":"
                        + (minutes < 10 ? '0' + minutes : minutes.toString());
                    SystemInformation.semanticContext.setUserTimeZone(formattedTimeZone);
                    SystemInformation.semanticContext.setDeviceBrowserName(SystemInformation._getBrowserName());
                    SystemInformation.semanticContext.setDeviceBrowserVersion(SystemInformation._getBrowserVersion());
                    SystemInformation.semanticContext.setDeviceOsName(SystemInformation._getOsName());
                    SystemInformation.semanticContext.setDeviceOsVersion(SystemInformation._getOsVersion());
                    SystemInformation.semanticContext.setDeviceId(documentInfo.deviceId);
                    SystemInformation.firstLaunchTime = documentInfo.firstLaunchTime;
                };
                SystemInformation.checkAndUpdateDeviceId = function (deviceId) {
                    // amitap - cookies are not supported by web worker
                    // var oldDeviceId = SystemInformation._getCookie(SystemInformation.DEVICE_ID_COOKIE);
                    // if (oldDeviceId != deviceId) {
                    //     SystemInformation._setCookie(SystemInformation.DEVICE_ID_COOKIE, deviceId);
                    //     SystemInformation._setCookie(SystemInformation.FIRST_LAUNCH_TIME_COOKIE, (new Date()).getTime().toString());
                    // }
                    // var firstLaunchTime = SystemInformation._getCookie(SystemInformation.FIRST_LAUNCH_TIME_COOKIE);
                    // SystemInformation.firstLaunchTime = parseInt(firstLaunchTime);
                };
                SystemInformation._setCookie = function (cname, cvalue) {
                    // amitap - cookies are not supported by web worker
                    // var expires = "expires=Mon, 31 Dec 2029 23:59:59 GMT";
                    // document.cookie = cname + "=" + cvalue + "; " + expires;
                };
                SystemInformation._getCookie = function (cname) {
                    // amitap - cookies are not supported by web worker
                    /*var name = cname + "=";
                    var ca = document.cookie.split(';');
                    for (var i = 0; i < ca.length; i++) {
                        var c = ca[i];
                        var j = 0;
                        while (c.charAt(j) == ' ') {
                            j++;
                        }
                        c = c.substring(j);
                        if (c.indexOf(name) == 0) return c.substring(name.length, c.length);
                    }*/
                    return "";
                };
                SystemInformation._getUserAgent = function () {
                    // amitap - document and window objects are not supported by web worker
                    return SystemInformation.documentInfo.userAgent; // window.navigator.userAgent;
                };
                SystemInformation._userAgentContainsString = function (searchString) {
                    return SystemInformation._getUserAgent().indexOf(searchString) > -1;
                };
                SystemInformation._isIe = function () {
                    return SystemInformation._userAgentContainsString('Trident');
                };
                SystemInformation._isEdge = function () {
                    return SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.EDGE);
                };
                SystemInformation._isOpera = function () {
                    return SystemInformation._userAgentContainsString('OPR/');
                };
                SystemInformation._getBrowserName = function () {
                    if (SystemInformation._isOpera()) {
                        return SystemInformation.BROWSERS.UNKNOWN;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.PHANTOMJS)) {
                        return SystemInformation.BROWSERS.PHANTOMJS;
                    }
                    if (SystemInformation._isEdge()) {
                        return SystemInformation.BROWSERS.EDGE;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.ELECTRON)) {
                        return SystemInformation.BROWSERS.ELECTRON;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.CHROME)) {
                        return SystemInformation.BROWSERS.CHROME;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.FIREFOX)) {
                        return SystemInformation.BROWSERS.FIREFOX;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.SAFARI)) {
                        return SystemInformation.BROWSERS.SAFARI;
                    }
                    if (SystemInformation._userAgentContainsString(SystemInformation.BROWSERS.SKYPE_SHELL)) {
                        return SystemInformation.BROWSERS.SKYPE_SHELL;
                    }
                    if (SystemInformation._isIe()) {
                        return SystemInformation.BROWSERS.MSIE;
                    }
                    return SystemInformation.BROWSERS.UNKNOWN;
                };
                SystemInformation._getBrowserVersion = function () {
                    if (SystemInformation._isIe()) {
                        return getIeVersion();
                    }
                    else {
                        return getOtherVersion(SystemInformation._getBrowserName());
                    }
                    function getIeVersion() {
                        var ieVersionMatches, userAgent = SystemInformation._getUserAgent(), classicIeVersionMatches = userAgent.match(new RegExp(SystemInformation.BROWSERS.MSIE + ' ' + SystemInformation.REGEX_VERSION));
                        if (classicIeVersionMatches) {
                            return classicIeVersionMatches[1];
                        }
                        else {
                            ieVersionMatches = userAgent.match(new RegExp('rv:' + SystemInformation.REGEX_VERSION));
                            if (ieVersionMatches) {
                                return ieVersionMatches[1];
                            }
                        }
                    }
                    function getOtherVersion(browserString) {
                        var matches;
                        if (browserString === SystemInformation.BROWSERS.SAFARI) {
                            browserString = 'Version';
                        }
                        matches = SystemInformation._getUserAgent().match(new RegExp(browserString + '/' + SystemInformation.REGEX_VERSION));
                        if (matches) {
                            return matches[1];
                        }
                        return SystemInformation.UNKNOWN_VERSION;
                    }
                };
                SystemInformation._getOsName = function () {
                    var win = /(windows|win32)/i, winrt = / arm;/i, winphone = /windows\sphone\s\d+\.\d+/i, osx = /(macintosh|mac os x)/i, ios = /(iPad|iPhone|iPod)(?=.*like Mac OS X)/i, linux = /(linux|joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk)/i, android = /android/i;
                    if (SystemInformation._getUserAgent().match(winphone)) {
                        return SystemInformation.OPERATING_SYSTEMS.WINDOWS_PHONE;
                    }
                    if (SystemInformation._getUserAgent().match(winrt)) {
                        return SystemInformation.OPERATING_SYSTEMS.WINDOWS_RT;
                    }
                    if (SystemInformation._getUserAgent().match(ios)) {
                        return SystemInformation.OPERATING_SYSTEMS.IOS;
                    }
                    if (SystemInformation._getUserAgent().match(android)) {
                        return SystemInformation.OPERATING_SYSTEMS.ANDROID;
                    }
                    if (SystemInformation._getUserAgent().match(linux)) {
                        return SystemInformation.OPERATING_SYSTEMS.LINUX;
                    }
                    if (SystemInformation._getUserAgent().match(osx)) {
                        return SystemInformation.OPERATING_SYSTEMS.MACOSX;
                    }
                    if (SystemInformation._getUserAgent().match(win)) {
                        return SystemInformation.OPERATING_SYSTEMS.WINDOWS;
                    }
                    return SystemInformation.OPERATING_SYSTEMS.UNKNOWN;
                };
                SystemInformation._getOsVersion = function () {
                    if (SystemInformation._getOsName() === SystemInformation.OPERATING_SYSTEMS.WINDOWS) {
                        return getWindowsVersion();
                    }
                    if (SystemInformation._getOsName() === SystemInformation.OPERATING_SYSTEMS.MACOSX) {
                        return getMacOsxVersion();
                    }
                    return SystemInformation.UNKNOWN_VERSION;
                    function getWindowsVersion() {
                        var ntVersionMatches = SystemInformation._getUserAgent().match(new RegExp('Windows NT ' + SystemInformation.REGEX_VERSION));
                        if (ntVersionMatches && SystemInformation.VERSION_MAPPINGS[ntVersionMatches[1]]) {
                            return SystemInformation.VERSION_MAPPINGS[ntVersionMatches[1]];
                        }
                        return SystemInformation.UNKNOWN_VERSION;
                    }
                    function getMacOsxVersion() {
                        var macOsxVersionInUserAgentMatches = SystemInformation._getUserAgent().match(new RegExp(SystemInformation.OPERATING_SYSTEMS.MACOSX + ' ' + SystemInformation.REGEX_VERSION_MAC));
                        if (macOsxVersionInUserAgentMatches) {
                            var versionString = macOsxVersionInUserAgentMatches[1].replace(/_/g, '.');
                            var components = [];
                            if (versionString) {
                                var delimiter = getDelimiter(versionString);
                                if (delimiter) {
                                    components = versionString.split(delimiter);
                                    return components[0];
                                }
                                else {
                                    return versionString;
                                }
                            }
                        }
                        return SystemInformation.UNKNOWN_VERSION;
                    }
                    function getDelimiter(versionString) {
                        if (versionString.indexOf('.') > -1) {
                            return '.';
                        }
                        if (versionString.indexOf('_') > -1) {
                            return '_';
                        }
                        return null;
                    }
                };
                return SystemInformation;
            }());
            SystemInformation.semanticContext = new SemanticContext(true);
            SystemInformation.firstLaunchTime = -1;
            SystemInformation.BROWSERS = {
                MSIE: 'MSIE',
                CHROME: 'Chrome',
                FIREFOX: 'Firefox',
                SAFARI: 'Safari',
                EDGE: 'Edge',
                ELECTRON: 'Electron',
                SKYPE_SHELL: 'SkypeShell',
                PHANTOMJS: 'PhantomJS',
                UNKNOWN: 'Unknown'
            };
            SystemInformation.OPERATING_SYSTEMS = {
                WINDOWS: 'Windows',
                MACOSX: 'Mac OS X',
                WINDOWS_PHONE: 'Windows Phone',
                WINDOWS_RT: 'Windows RT',
                IOS: 'iOS',
                ANDROID: 'Android',
                LINUX: 'Linux',
                UNKNOWN: 'Unknown'
            };
            SystemInformation.VERSION_MAPPINGS = {
                '5.1': 'XP',
                '6.0': 'Vista',
                '6.1': '7',
                '6.2': '8',
                '6.3': '8.1',
                '10.0': '10'
            };
            SystemInformation.REGEX_VERSION = '([\\d,.]+)';
            SystemInformation.REGEX_VERSION_MAC = '([\\d,_,.]+)';
            SystemInformation.UNKNOWN_VERSION = "Unknown";
            SystemInformation.DEVICE_ID_COOKIE = "MicrosoftApplicationsTelemetryDeviceId";
            SystemInformation.FIRST_LAUNCH_TIME_COOKIE = "MicrosoftApplicationsTelemetryFirstLaunchTime";
            var SessionState;
            (function (SessionState) {
                SessionState[SessionState["STARTED"] = 0] = "STARTED";
                SessionState[SessionState["ENDED"] = 1] = "ENDED";
            })(SessionState = telemetry.SessionState || (telemetry.SessionState = {}));
            /**
             * LogManager class allows initialization of the telemetry library.
             */
            var LogManager = (function () {
                function LogManager() {
                }
                LogManager.initialize = function (documentInfo, tenantToken) {
                    if (!LogManager._initialized) {
                        if (!tenantToken) {
                            throw new Exception(TelemetryError.INVALID_TENANT_TOKEN);
                        }
                        LogManager._defaultToken = tenantToken;
                        if (!LogManager._config.collectorUrl) {
                            LogManager._config.collectorUrl = "https://browser.pipe.aria.microsoft.com/Collector/3.0/";
                        }
                        if (!telemetry.globalTelemetryManager) {
                            telemetry.globalTelemetryManager = telemetry._sender.TelemetryManagerFactory.CreateTelemetryManager();
                            telemetry.globalTelemetryManager.Initialize(LogManager._config);
                        }
                        telemetry.globalTelemetryManager.Start();
                        SystemInformation.initialize(documentInfo);
                        LogManager._initialized = true;
                    }
                };
                LogManager.initializeWithConfiguration = function (documentInfo, tenantToken, configuration) {
                    if (!configuration.collectorUrl) {
                        throw new Exception(TelemetryError.INVALID_COLLECTOR_URL);
                    }
                    LogManager._config.collectorUrl = configuration.collectorUrl;
                    LogManager.initialize(documentInfo, tenantToken);
                };
                LogManager.flush = function (func) {
                    telemetry.globalTelemetryManager.Flush(func);
                };
                /**
                * When events have been sent or sent failed, you can get the notification
                * if you registered the listener. If the listener has been added already,
                * the function will do nothing.
                *
                * @param func (callbackType: microsoft.applications.telemetry._sender.CallbackEventType, responseCode: number, tenantToken: string,
                *  events: microsoft.applications.telemetry.datamodels.Record[]) => any
                */
                LogManager.addCallbackListener = function (func) {
                    if (LogManager._initialized) {
                        telemetry.globalTelemetryManager.AddListener(func);
                    }
                };
                LogManager.setContext = function (key, value, pii) {
                    LogManager._contextProperties.setProperty(key, value, pii);
                };
                LogManager.isInitialized = function () {
                    return LogManager._initialized;
                };
                LogManager.getDefaultToken = function () {
                    return LogManager._defaultToken;
                };
                LogManager.getSemanticContext = function () {
                    return LogManager._semanticContext;
                };
                /******* TEST_INJECTION_START *******/
                LogManager.__backToUninitialized = function () {
                    LogManager._config = new telemetry._sender.TelemetryConfig();
                    LogManager._semanticContext = new SemanticContext(true);
                    LogManager._contextProperties = new EventProperties();
                    telemetry.globalTelemetryManager = telemetry._sender.TelemetryManagerFactory.CreateTelemetryManager();
                    LogManager._initialized = false;
                };
                return LogManager;
            }());
            LogManager._initialized = false;
            LogManager._defaultToken = null;
            LogManager._config = new telemetry._sender.TelemetryConfig();
            LogManager._contextProperties = new EventProperties();
            LogManager._semanticContext = new SemanticContext(true);
            telemetry.LogManager = LogManager;
            /**
             * Contains methods to log custom events.
             */
            var Logger = (function () {
                function Logger(tenantToken) {
                    this._initId = telemetry.datamodels.utils.GetGuid();
                    this._sequence = 0;
                    this._tenantToken = null;
                    this._contextProperties = new EventProperties();
                    this._semanticContext = new SemanticContext(false);
                    this._sessionStartTime = 0;
                    this._sessionId = null;
                    if (!tenantToken) {
                        this._tenantToken = LogManager.getDefaultToken();
                    }
                    else {
                        this._tenantToken = tenantToken;
                    }
                }
                /**
                * Log a custom event, including custom key-value properties.
                * * @param {microsoft.applications.telemetry.EventProperties} eventProperties - properties of the custom event.
                */
                Logger.prototype.logEvent = function (eventProperties) {
                    if (!eventProperties.name) {
                        throw new Exception(TelemetryError.MISSING_EVENT_PROPERTIES_NAME);
                    }
                    var event = this._createEventRecord(eventProperties.name, eventProperties.eventType);
                    this._addCustomPropertiesToEvent(event, eventProperties);
                    this._sendRecord(event);
                };
                /**
                 * Logs a failure event such as an application exception.
                 * @param {String} signature (req) - a detailed string that identifies the bucket of the failure.
                 * @param {String} detail (req) - details of the failure.
                 * @param {String} category - category of the failure such as application error, hang, or crash.
                 * @param {String} id - identifier that could be used to uniquely identify or reference this failure.
                 * @param {microsoft.applications.telemetry.EventProperties} properties - properties of the failure event, can be null.
                 */
                Logger.prototype.logFailure = function (signature, detail, category, id, properties) {
                    if (!signature) {
                        throw new Exception(TelemetryError.MISSING_FAILURE_SIGNATURE);
                    }
                    if (!detail) {
                        throw new Exception(TelemetryError.MISSING_FAILURE_DETAIL);
                    }
                    var event = this._createEventRecord("failure", "failure");
                    event.Extension.Add("Failure.Signature", signature);
                    event.Extension.Add("Failure.Detail", detail);
                    if (category) {
                        event.Extension.Add("Failure.Category", category);
                    }
                    if (id) {
                        event.Extension.Add("Failure.Id", id);
                    }
                    this._addCustomPropertiesToEvent(event, properties);
                    this._sendRecord(event);
                };
                /**
                 * Logs a page view event which is normally a result of a user action on a UI page such as search query, content request or page navigation.
                 * @param {String} id (req) - an identifier that could be used to uniquely identify or reference this page.
                 * @param {String} pageName (req) - the name of the page.
                 * @param {String} category - the category for which this page belongs to.
                 * @param {String} uri - uri of this page.
                 * @param {String} referrerUri - uri that refers to this page.
                 * @param {microsoft.applications.telemetry.EventProperties} properties - properties of the page view event, can be null.
                 */
                Logger.prototype.logPageView = function (id, pageName, category, uri, referrerUri, properties) {
                    if (!id) {
                        throw new Exception(TelemetryError.MISSING_PAGEVIEW_ID);
                    }
                    if (!pageName) {
                        throw new Exception(TelemetryError.MISSING_PAGEVIEW_NAME);
                    }
                    var event = this._createEventRecord("pageview", "pageview");
                    event.Extension.Add("PageView.Id", id);
                    event.Extension.Add("PageView.Name", pageName);
                    if (category) {
                        event.Extension.Add("PageView.Category", category);
                    }
                    if (uri) {
                        event.Extension.Add("PageView.Uri", uri);
                    }
                    if (referrerUri) {
                        event.Extension.Add("PageView.ReferrerUri", referrerUri);
                    }
                    this._addCustomPropertiesToEvent(event, properties);
                    this._sendRecord(event);
                };
                /**
                 * Logs the session state.
                 * Note: Logging session start while a session already exists will be no-op. Similarly, logging
                 * session end while a session does not exist will be no-op too.
                 * @param {microsoft.applications.telemetry.SessionState} state (req) - the session's state.
                 * @param {microsoft.applications.telemetry.EventProperties} properties - properties of the session event, can be null.
                 */
                Logger.prototype.logSession = function (state, properties) {
                    if (state !== SessionState.STARTED && state !== SessionState.ENDED) {
                        throw new Exception(TelemetryError.INVALID_SESSION_STATE);
                    }
                    var event = this._createEventRecord("session", "session");
                    if (state === SessionState.STARTED) {
                        if (this._sessionStartTime > 0) {
                            //Session already exists
                            return;
                        }
                        this._sessionStartTime = (new Date()).getTime();
                        this._sessionId = telemetry.datamodels.utils.GetGuid();
                        event.Extension.Add("Session.Id", this._sessionId);
                        event.Extension.Add("Session.State", "Started");
                    }
                    else if (state === SessionState.ENDED) {
                        if (this._sessionStartTime == 0) {
                            //Session does not exist
                            return;
                        }
                        var sessionDuration = Math.floor(((new Date()).getTime() - this._sessionStartTime) / 1000);
                        event.Extension.Add("Session.Duration", sessionDuration.toString());
                        event.Extension.Add("Session.DurationBucket", this._getSessionDurationFromTime(sessionDuration));
                        event.Extension.Add("Session.Id", this._sessionId);
                        event.Extension.Add("Session.State", "Ended");
                        this._sessionId = null;
                        this._sessionStartTime = 0;
                    }
                    event.Extension.Add("Session.FirstLaunchTime", this._getISOString(new Date(SystemInformation.firstLaunchTime)));
                    this._addCustomPropertiesToEvent(event, properties);
                    this._sendRecord(event);
                };
                Logger.prototype.getSessionId = function () {
                    return this._sessionId;
                };
                Logger.prototype.setContext = function (key, value, pii) {
                    this._contextProperties.setProperty(key, value, pii);
                };
                Logger.prototype.getSemanticContext = function () {
                    return this._semanticContext;
                };
                Logger.prototype._getSessionDurationFromTime = function (timeInSec) {
                    if (timeInSec < 0) {
                        return "Undefined";
                    }
                    else if (timeInSec <= 3) {
                        return "UpTo3Sec";
                    }
                    else if (timeInSec <= 10) {
                        return "UpTo10Sec";
                    }
                    else if (timeInSec <= 30) {
                        return "UpTo30Sec";
                    }
                    else if (timeInSec <= 60) {
                        return "UpTo60Sec";
                    }
                    else if (timeInSec <= 180) {
                        return "UpTo3Min";
                    }
                    else if (timeInSec <= 600) {
                        return "UpTo10Min";
                    }
                    else if (timeInSec <= 1800) {
                        return "UpTo30Min";
                    }
                    return "Above30Min";
                };
                Logger.prototype._createEventRecord = function (eventName, recordType) {
                    var event = new telemetry.datamodels.Record();
                    if (!recordType) {
                        recordType = "custom";
                    }
                    event.EventType = eventName.toLowerCase();
                    event.Type = recordType.toLowerCase();
                    event.Extension.Add("EventInfo.Source", "JS_default_source");
                    event.Extension.Add("EventInfo.InitId", this._initId);
                    this._sequence++;
                    event.Extension.Add("EventInfo.Sequence", this._sequence.toString());
                    event.Extension.Add("EventInfo.Name", eventName.toLowerCase());
                    var date = new Date();
                    event.Timestamp = telemetry.datamodels.utils.GetTimeStampWithValue(date.getTime());
                    event.Extension.Add("EventInfo.Time", this._getISOString(date));
                    event.Extension.Add("EventInfo.SdkVersion", "ACT-Web-JS-" + clienttelemetry_build.version);
                    return event;
                };
                Logger.prototype._getISOString = function (date) {
                    function twoDigit(n) {
                        // Format integers to have at least two digits.
                        return n < 10 ? '0' + n : n.toString();
                    }
                    function threeDigit(n) {
                        // Format integers to have at least three digits.
                        if (n < 10) {
                            return '00' + n;
                        }
                        else if (n < 100) {
                            return '0' + n;
                        }
                        return n.toString();
                    }
                    return date.getUTCFullYear() + '-' +
                        twoDigit(date.getUTCMonth() + 1) + '-' +
                        twoDigit(date.getUTCDate()) + 'T' +
                        twoDigit(date.getUTCHours()) + ':' +
                        twoDigit(date.getUTCMinutes()) + ':' +
                        twoDigit(date.getUTCSeconds()) + '.' +
                        threeDigit(date.getUTCMilliseconds()) + 'Z';
                };
                Logger.prototype._addCustomPropertiesToEvent = function (event, eventProperties) {
                    this._addSemanticContext(event, SystemInformation.semanticContext);
                    this._addSemanticContext(event, LogManager._semanticContext);
                    this._addSemanticContext(event, this._semanticContext);
                    if (this._sessionId) {
                        event.Extension.Add("Session.Id", this._sessionId);
                    }
                    this._addEventPropertiesToEvent(event, LogManager._contextProperties);
                    this._addEventPropertiesToEvent(event, this._contextProperties);
                    this._addEventPropertiesToEvent(event, eventProperties);
                };
                Logger.prototype._addSemanticContext = function (event, semanticContext) {
                    if (semanticContext && semanticContext.contextMap.Count() > 0) {
                        var contextBuffer = semanticContext.contextMap.GetBuffer();
                        for (var i = 0; i < contextBuffer.length; i++) {
                            if (contextBuffer[i].Key == "UserInfo.Id" && semanticContext.piiKind != telemetry.datamodels.PIIKind.NotSet) {
                                event.AddOrReplacePII(contextBuffer[i].Key, contextBuffer[i].Value, semanticContext.piiKind);
                            }
                            else {
                                event.Extension.AddOrReplace(contextBuffer[i].Key, contextBuffer[i].Value);
                            }
                        }
                    }
                };
                Logger.prototype._addEventPropertiesToEvent = function (event, eventProperties) {
                    if (eventProperties) {
                        if (eventProperties.timestamp && eventProperties.timestamp >= (new Date("1/1/2000")).getTime()) {
                            event.Timestamp = telemetry.datamodels.utils.GetTimeStampWithValue(eventProperties.timestamp);
                            event.Extension.AddOrReplace("EventInfo.Time", this._getISOString(new Date(eventProperties.timestamp)));
                        }
                        if (eventProperties.name) {
                            event.EventType = eventProperties.name.toLowerCase();
                            event.Extension.AddOrReplace("EventInfo.Name", eventProperties.name.toLowerCase());
                        }
                        var properties = eventProperties.properties;
                        if (properties) {
                            for (var i in properties) {
                                if (properties[i].key && (typeof properties[i].key == "string") && (properties[i].value || properties[i].value == false || properties[i].value == 0
                                    || properties[i].value == "")) {
                                    if (Property._isPii(properties[i].pii)) {
                                        event.AddOrReplacePII(properties[i].key, properties[i].value.toString(), properties[i].pii);
                                        event.Extension.Remove(properties[i].key);
                                    }
                                    else {
                                        event.Extension.AddOrReplace(properties[i].key, properties[i].value.toString());
                                        event.PIIExtensions.Remove(properties[i].key);
                                    }
                                }
                            }
                        }
                    }
                };
                Logger.prototype._sendRecord = function (record) {
                    if (LogManager.isInitialized()) {
                        telemetry.globalTelemetryManager.SendAsync(this._tenantToken, [record]);
                    }
                };
                return Logger;
            }());
            telemetry.Logger = Logger;
        })(telemetry = applications.telemetry || (applications.telemetry = {}));
    })(applications = microsoft.applications || (microsoft.applications = {}));
})(microsoft || (microsoft = {}));
;
/** \file ecsclient.ts
    This filed defined the ecsclient class.
    \author yuboxie
    \date 2014-02
*/
var ecs;
(function (ecs) {
    var ECS_ERROR;
    (function (ECS_ERROR) {
        ECS_ERROR[ECS_ERROR["ECS_ERROR_OK"] = 0] = "ECS_ERROR_OK";
        ECS_ERROR[ECS_ERROR["ECS_ERROR_INVALID_STATUS"] = 1] = "ECS_ERROR_INVALID_STATUS";
        ECS_ERROR[ECS_ERROR["ECS_ERROR_INVALID_RESPONSE"] = 6] = "ECS_ERROR_INVALID_RESPONSE";
        ECS_ERROR[ECS_ERROR["ECS_ERROR_INVALID_CONFIG"] = 8] = "ECS_ERROR_INVALID_CONFIG";
    })(ECS_ERROR = ecs.ECS_ERROR || (ecs.ECS_ERROR = {}));
    var Exception = (function () {
        function Exception(errorCode) {
            this._errorCode = errorCode;
        }
        Exception.prototype.ErrorCode = function () {
            return this._errorCode;
        };
        Exception.prototype.toString = function () {
            switch (this._errorCode) {
                case ECS_ERROR.ECS_ERROR_OK:
                    return "ECS_ERROR_OK";
                case ECS_ERROR.ECS_ERROR_INVALID_STATUS:
                    return "ECS_ERROR_INVALID_STATUS";
                case ECS_ERROR.ECS_ERROR_INVALID_RESPONSE:
                    return "ECS_ERROR_INVALID_RESPONSE";
                case ECS_ERROR.ECS_ERROR_INVALID_CONFIG:
                    return "ECS_ERROR_INVALID_CONFIG";
                default:
                    return "Unknown error";
            }
        };
        return Exception;
    }());
    ecs.Exception = Exception;
    var CallbackEventType;
    (function (CallbackEventType) {
        CallbackEventType[CallbackEventType["CONFIG_UPDATED"] = 0] = "CONFIG_UPDATED";
        CallbackEventType[CallbackEventType["TOKEN_IS_INVALID"] = 1] = "TOKEN_IS_INVALID";
    })(CallbackEventType = ecs.CallbackEventType || (ecs.CallbackEventType = {}));
    /** EcsClientConfig of EcsClient

        \note
        EcsClient will not hold the reference of this config.
    */
    var EcsClientConfig = (function () {
        function EcsClientConfig() {
        }
        // Keep only the required fields.
        EcsClientConfig.prototype.Copy = function (from) {
            this.uiVersion = from.uiVersion;
            this.log = from.log;
            this.servers = undefined;
            if (from.servers && from.servers.length) {
                this.servers = [];
                for (var i = 0; i < from.servers.length; ++i) {
                    this.servers.push(from.servers[i]);
                }
            }
        };
        return EcsClientConfig;
    }());
    ecs.EcsClientConfig = EcsClientConfig;
    var EcsClientFactory = (function () {
        function EcsClientFactory() {
        }
        EcsClientFactory.CreateEcsClient = function () {
            return new EcsClientImpl();
        };
        /******* TEST_INJECTION_START *******/
        /******* The following function is only defined for test injection, you should never invoke them *********/
        EcsClientFactory.__ChangeFailedRetryFactorInMS = function (interval) {
            Defaults.FailedRetryFactorInMS = interval;
        };
        return EcsClientFactory;
    }());
    ecs.EcsClientFactory = EcsClientFactory;
    //
    // defaults
    //
    var Defaults = (function () {
        function Defaults() {
        }
        return Defaults;
    }());
    Defaults.Servers = ["https://config.teams.microsoft.com/config/v1/Skype/"];
    Defaults.RefreshIntervalInMS = 60 * 60 * 1000;
    Defaults.FailedRetryFactorInMS = 10 * 1000;
    Defaults.MaxRetryIntervalForFailedInMS = 60 * 60 * 1000;
    ;
    //
    // Impl
    //
    /** EcsClient status.

        \note
        The status order is very important, don't modify it unless you know what you are doing.
    */
    var EcsClientStatus;
    (function (EcsClientStatus) {
        EcsClientStatus[EcsClientStatus["Created"] = 0] = "Created";
        EcsClientStatus[EcsClientStatus["Initialized"] = 1] = "Initialized";
        EcsClientStatus[EcsClientStatus["Started"] = 2] = "Started";
        EcsClientStatus[EcsClientStatus["Loading"] = 3] = "Loading";
    })(EcsClientStatus || (EcsClientStatus = {}));
    var EcsClientImpl = (function () {
        function EcsClientImpl() {
            this._tag = 0;
            this._status = EcsClientStatus.Created;
            this._listeners = [];
            this._failedTimes = {};
            this._skypeToken = null;
            this._pendingToken = [];
            this._queryParams = {};
            /******* TEST_INJECTION_END *********/
        }
        //
        // public functions
        //
        EcsClientImpl.prototype.Initialize = function (config) {
            if (this._status != EcsClientStatus.Created) {
                throw new Exception(ECS_ERROR.ECS_ERROR_INVALID_STATUS);
            }
            // if any required field missing, throw exception.
            if (!config || !config.uiVersion) {
                throw new Exception(ECS_ERROR.ECS_ERROR_INVALID_CONFIG);
            }
            // cache the config
            this._config = new EcsClientConfig();
            this._config.Copy(config);
            // Escape special characters
            this._config.uiVersion = this._config.uiVersion.replace('/', '_');
            // prepare servers, if user doesn't supply server, use the default servers.
            var servers = [];
            if (this._config.servers && this._config.servers.length) {
                servers = this._config.servers;
            }
            else {
                for (var i = 0; i < Defaults.Servers.length; ++i) {
                    servers.push(Defaults.Servers[i]);
                }
            }
            // re-order the servers
            var reorderServers = [];
            while (servers.length) {
                var index = Math.floor(Math.random() * servers.length);
                reorderServers.push(servers[index]);
                if (index == servers.length - 1) {
                    servers.pop();
                }
                else {
                    servers[index] = servers.pop();
                }
            }
            this._config.servers = reorderServers;
            // log the servers
            this._Info("servers: " + this._config.servers.join(","));
            // set the status
            this._status = EcsClientStatus.Initialized;
            this._Verbose("Initialize() done");
        };
        EcsClientImpl.prototype.AddListener = function (func) {
            this._Verbose("AddListener()");
            this._CheckStatus(EcsClientStatus.Initialized);
            for (var i = 0; i < this._listeners.length; ++i) {
                if (this._listeners[i] == func) {
                    this._Verbose("the listener has been added already, index: " + i);
                    return;
                }
            }
            this._listeners.push(func);
        };
        EcsClientImpl.prototype.RemoveListener = function (func) {
            this._Verbose("RemoveListener()");
            this._CheckStatus(EcsClientStatus.Initialized);
            for (var i = 0; i < this._listeners.length; ++i) {
                if (this._listeners[i] == func) {
                    if (i == this._listeners.length - 1) {
                        this._listeners.pop();
                    }
                    else {
                        this._listeners[i] = this._listeners.pop();
                    }
                    return;
                }
            }
        };
        EcsClientImpl.prototype.Start = function () {
            this._Verbose("Start()");
            this._CheckStatus(EcsClientStatus.Initialized);
            if (this._status >= EcsClientStatus.Started) {
                this._Verbose("Start() already, ignore");
                return;
            }
            ++this._tag;
            this._status = EcsClientStatus.Started;
            // load config immediately.
            this.ConfigReloadAsync();
        };
        EcsClientImpl.prototype.Stop = function () {
            this._Verbose("Stop()");
            this._CheckStatus(EcsClientStatus.Initialized);
            if (this._status == EcsClientStatus.Initialized) {
                this._Verbose("Stop() already, ignore");
                return;
            }
            //
            // do stop work
            //
            this._CleanTimer();
            this._ecsConfig = null;
            this._etag = null;
            this._expireTime = null;
            this._failedTimes = {};
            this._status = EcsClientStatus.Initialized;
        };
        EcsClientImpl.prototype.GetETag = function () {
            this._CheckStatus(EcsClientStatus.Started);
            return this._etag;
        };
        EcsClientImpl.prototype.SetSkypeToken = function (token) {
            this._Verbose("SetToken()");
            this._CheckStatus(EcsClientStatus.Started);
            // Ignore all empty stuff like "", undefined;
            token = token ? token : null;
            if (this._status == EcsClientStatus.Loading) {
                this._Verbose("A request is ongoing, postpone.");
                this._pendingToken.push(token);
            }
            else {
                this._skypeToken = token;
                // reload config after token is refreshed
                this.ConfigReloadAsync();
            }
        };
        EcsClientImpl.prototype.ConfigReloadAsync = function () {
            var _this = this;
            this._Verbose("ConfigReloadAsync()");
            this._CheckStatus(EcsClientStatus.Started);
            if (this._status == EcsClientStatus.Loading) {
                this._Verbose("ConfigReloadAsync() is loading, ignore");
                return;
            }
            // always clean the timer, because configReloadAsync() will reload immediately.
            this._CleanTimer();
            var tag = this._tag;
            var server = this._config.servers[0] + this._config.uiVersion;
            // Insert query parameters
            var body = {};
            for (var _ns in this._queryParams) {
                body[_ns] = {};
                for (var key in this._queryParams[_ns]) {
                    body[_ns][key] = this._queryParams[_ns][key];
                }
            }
            body["Headers"] = {};
            if (!sct.Utils.IsUsingXDomainRequest() && this._etag) {
                // IMPORTANT
                // We should never apply ETag on XDomainRequest
                // because it treats 304 as error, which means, there's
                // no way to distinguish it with typical errors such as
                // 401. To solve this problem, we always remove ETag in
                // request so we can always get 200 from server.
                body["Headers"]["If-None-Match"] = this._etag;
            }
            if (this._skypeToken) {
                body["Headers"]["SkypeToken"] = this._skypeToken;
            }
            if (sct.Utils.keys(body["Headers"]).length == 0) {
                delete body["Headers"];
            }
            sct.Utils.ajax({
                type: "POST",
                url: server,
                data: JSON.stringify(body),
                complete: function (jqXHR) { return _this._HttpCallback(tag, jqXHR); }
            });
            this._status = EcsClientStatus.Loading;
        };
        EcsClientImpl.prototype.AddQueryParameter = function (_namespace, key, value) {
            if (key && value) {
                if (!_namespace) {
                    _namespace = "global";
                }
                // Make sure external user can't insert untrusted data in
                // Headers.
                var ns = _namespace.toLowerCase();
                if (ns == "headers") {
                    return;
                }
                if (!(ns in this._queryParams)) {
                    this._queryParams[ns] = {};
                }
                this._queryParams[ns][key.toLowerCase()] = value.toLowerCase();
            }
        };
        EcsClientImpl.prototype.RemoveQueryParameter = function (_namespace, key) {
            var ns = "global";
            if (_namespace) {
                ns = _namespace.toLowerCase();
            }
            if (key) {
                key = key.toLowerCase();
                if ((ns in this._queryParams) &&
                    (key in this._queryParams[ns])) {
                    delete this._queryParams[ns][key];
                    if (sct.Utils.keys(this._queryParams[ns]).length == 0) {
                        delete this._queryParams[ns];
                    }
                }
            }
        };
        EcsClientImpl.prototype.RemoveQueryParameterByNamespace = function (_namespace) {
            if (!_namespace) {
                _namespace = "global";
            }
            else {
                _namespace = _namespace.toLowerCase();
            }
            // It's possible that we delete "global", which means
            // there's no global parameter any more.
            delete this._queryParams[_namespace];
        };
        EcsClientImpl.prototype.GetSetting = function (agent, path, defaultValue) {
            this._CheckStatus(EcsClientStatus.Started);
            if (!agent) {
                return this._ecsConfig ? JSON.stringify(this._ecsConfig) : "";
            }
            return this._GetSettingAsDefault(agent, path, defaultValue, JSON.stringify);
        };
        EcsClientImpl.prototype.GetSettingAsString = function (agent, path, defaultValue) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsDefault(agent, path, defaultValue, function (i) { return "" + i; });
        };
        EcsClientImpl.prototype.GetSettingAsInt = function (agent, path, defafultValue) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsDefault(agent, path, defafultValue, parseInt);
        };
        EcsClientImpl.prototype.GetSettingAsBool = function (agent, path, defaultValue) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsDefault(agent, path, defaultValue, function (i) { return !!i; });
        };
        EcsClientImpl.prototype.GetSettingAsReal = function (agent, path, defaultValue) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsDefault(agent, path, defaultValue, parseFloat);
        };
        EcsClientImpl.prototype.GetSettingAsList = function (agent, path) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsList(agent, path, function (i) { return "" + i; });
        };
        EcsClientImpl.prototype.GetSettingAsListOfInts = function (agent, path) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsList(agent, path, parseInt);
        };
        EcsClientImpl.prototype.GetSettingAsListOfReal = function (agent, path) {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetSettingAsList(agent, path, parseFloat);
        };
        EcsClientImpl.prototype.GetKeys = function (agent, path) {
            this._CheckStatus(EcsClientStatus.Started);
            if (!agent) {
                return this.GetAgents();
            }
            var normalizePath = this._NormalizePath(agent, path);
            return normalizePath ? this._GetObjectKeys(this._GetObject(normalizePath)) : [];
        };
        EcsClientImpl.prototype.GetAgents = function () {
            this._CheckStatus(EcsClientStatus.Started);
            return this._GetObjectKeys(this._ecsConfig);
        };
        //
        // util functions
        //
        EcsClientImpl.prototype._HttpCallback = function (tag, jqXHR) {
            this._Verbose("_HttpCallback");
            if (this._status != EcsClientStatus.Loading || tag != this._tag) {
                this._Verbose("_status != loading || tag != _tag, ignore");
                return;
            }
            // by default, no need retry
            var rescheduleTimer = true;
            var retry = false;
            try {
                if (jqXHR == null) {
                    this._Error("jqXHR is null. exception");
                    throw new Exception(ECS_ERROR.ECS_ERROR_INVALID_RESPONSE);
                }
                var result = this._ParseResponse(jqXHR);
                var statusCode = result["statuscode"];
                this._Info("status of HttpCallback: " + statusCode);
                if (statusCode >= 200 && statusCode <= 299) {
                    //
                    // handle success cases
                    //
                    var etag = result["etag"];
                    this._Verbose("etag: " + etag);
                    if (!etag) {
                        // etag shouldn't be empty, treat it as error
                        throw new Exception(ECS_ERROR.ECS_ERROR_INVALID_RESPONSE);
                    }
                    var expires = result["expires"];
                    this._Verbose("2xx: JSON.parse() success.");
                    // all success, cache the new config data
                    this._etag = etag;
                    this._ecsConfig = result["data"];
                    this._expireTime = result["expires"];
                    // notify user config is changed
                    this._Notify(CallbackEventType.CONFIG_UPDATED);
                }
                else {
                    //
                    // handle error case
                    //
                    switch (statusCode) {
                        case 304:
                            // IMPORTANT: IE8/IE9 should never reach here.
                            this._Verbose("Config is not changed. Update expire time only.");
                            this._expireTime = result["expires"];
                            break;
                        case 401:
                            this._Warning("token is invalid");
                            // Stop reschedule timer. We won't do it
                            // until user calls SetSkypeToken().
                            //
                            // Meanwhile, the invalid SkypeToken is
                            // still kept, so next ConfigReloadAsync()
                            // will not jump to default configuration.
                            // User must use SetSkypeToken() to make
                            // it continue.
                            rescheduleTimer = false;
                            // notify the user
                            this._Notify(CallbackEventType.TOKEN_IS_INVALID);
                            break;
                        case -1:
                            // Special case for IE8/IE9
                            rescheduleTimer = false;
                            break;
                        default:
                            throw new Exception(ECS_ERROR.ECS_ERROR_INVALID_RESPONSE);
                    }
                }
            }
            catch (e) {
                // exception/error occurs, let's re-try it.
                this._Error("exception: " + e);
                retry = true;
            }
            // schedule next try
            if (rescheduleTimer) {
                this._ScheduleTimer(retry);
            }
            // change the status to started
            this._status = EcsClientStatus.Started;
        };
        EcsClientImpl.prototype._Notify = function (callbackEventType) {
            for (var i = 0; i < this._listeners.length; ++i) {
                this._listeners[i](callbackEventType);
            }
        };
        EcsClientImpl.prototype._ScheduleTimer = function (isRetry) {
            var _this = this;
            // always cleanup the timer
            this._CleanTimer();
            if (isRetry) {
                // if Retry is true, that means there is error occurs, record the error
                var currentServer = this._config.servers.shift();
                if (!this._failedTimes[currentServer]) {
                    this._failedTimes[currentServer] = 1;
                }
                else {
                    ++this._failedTimes[currentServer];
                }
                // put the failed server to the end, so next time, we will try another server
                this._config.servers.push(currentServer);
                // caculate the next retry, get the failed times
                var failedTimes = this._failedTimes[this._config.servers[0]] || 0;
                var interval = 0;
                if (failedTimes) {
                    interval = Math.pow(2, failedTimes - 1) * Defaults.FailedRetryFactorInMS;
                    if (interval > Defaults.MaxRetryIntervalForFailedInMS) {
                        interval = Defaults.MaxRetryIntervalForFailedInMS;
                    }
                }
                this._timer = setTimeout(function () { return _this.ConfigReloadAsync(); }, interval);
            }
            else {
                // if Retry is false, that means there is no error,
                // clean up the server's error record
                this._failedTimes[this._config.servers[0]] = 0;
                var immediateSend = false;
                // Process pending requests, if any.
                if (this._pendingToken.length) {
                    this._Verbose("Pending token found.");
                    var nextToken = this._pendingToken.pop();
                    // Clear other tokens. No need to process every
                    // pending requests.
                    this._pendingToken.splice(0, this._pendingToken.length);
                    if (nextToken != this._skypeToken) {
                        // Immediately trigger next rollout, since we know
                        // we have a new token.
                        this._Verbose("Trigger new request immediately.");
                        this._skypeToken = nextToken;
                        immediateSend = true;
                    }
                }
                var interval = 0;
                if (!immediateSend) {
                    // for success case, next try time is set by
                    // expires time, if expires time is
                    // null or not valid, use the default time
                    // This is the regular case.
                    interval = Defaults.RefreshIntervalInMS;
                    if (this._expireTime) {
                        interval = this._expireTime - new Date().getTime();
                        if (interval < 0) {
                            interval = 0;
                        }
                    }
                }
                this._timer = setTimeout(function () { return _this.ConfigReloadAsync(); }, interval);
            }
        };
        EcsClientImpl.prototype._CleanTimer = function () {
            if (this._timer) {
                clearTimeout(this._timer);
                this._timer = null;
            }
        };
        EcsClientImpl.prototype._GetSettingAsDefault = function (agent, path, defaultValue, handler) {
            if (!agent) {
                return defaultValue;
            }
            var normalizePath = this._NormalizePath(agent, path);
            if (!normalizePath) {
                return defaultValue;
            }
            var obj = this._GetObject(normalizePath);
            if (obj == null) {
                return defaultValue;
            }
            try {
                return handler(obj);
            }
            catch (e) {
                return defaultValue;
            }
        };
        EcsClientImpl.prototype._GetSettingAsList = function (agent, path, handler) {
            if (!agent) {
                return [];
            }
            var normalizePath = this._NormalizePath(agent, path);
            if (!normalizePath) {
                return [];
            }
            var obj = this._GetObject(normalizePath);
            if (obj == null) {
                return [];
            }
            try {
                var res = [];
                for (var i = 0; i < obj.length; ++i) {
                    res.push(handler(obj[i]));
                }
                return res;
            }
            catch (e) {
                return [];
            }
        };
        EcsClientImpl.prototype._CheckStatus = function (minimalStatus) {
            if (this._status < minimalStatus) {
                this._Error(["status is error, current status:", this._status,
                    "minimalStatus:", minimalStatus].join(" "));
                throw new Exception(ECS_ERROR.ECS_ERROR_INVALID_STATUS);
            }
        };
        EcsClientImpl.prototype._GetObjectKeys = function (obj) {
            var keys = [];
            if (obj != null) {
                for (var key in obj) {
                    keys.push(key);
                }
            }
            return keys;
        };
        EcsClientImpl.prototype._GetObject = function (path) {
            var pathes = path.split('/');
            var obj = this._ecsConfig;
            for (var i = 0; i < pathes.length && obj; ++i) {
                obj = obj[pathes[i]];
            }
            return obj;
        };
        EcsClientImpl.prototype._NormalizePath = function (agent, path) {
            if (path != null && path.length && path[0] == '/') {
                path = path.substr(1);
            }
            if (path != null && path.length && path[path.length - 1] == '/') {
                path = path.substr(0, path.length - 1);
            }
            if (!path) {
                return agent;
            }
            else {
                return agent ? agent + "/" + path : path;
            }
        };
        // 
        // log functions
        //
        EcsClientImpl.prototype._Verbose = function (msg) {
            this._config && this._config.log && this._config.log.Verbose("[EcsClient]: " + msg);
        };
        EcsClientImpl.prototype._Info = function (msg) {
            this._config && this._config.log && this._config.log.Info("[EcsClient]: " + msg);
        };
        EcsClientImpl.prototype._Warning = function (msg) {
            this._config && this._config.log && this._config.log.Warning("[EcsClient]: " + msg);
        };
        EcsClientImpl.prototype._Error = function (msg) {
            this._config && this._config.log && this._config.log.Error("[EcsClient]: " + msg);
        };
        EcsClientImpl.prototype._ParseResponse = function (jqXHR) {
            // As per current server behavior:
            // 0. For IE8/IE9, there's no status code returned on error.
            // We always set it to 400, and give up retry.
            // 1. 304 will have empty body (ECS server behavior),
            // so the only way is to get it is from jqXHR.status;
            // 2. 401 in IE10 is replaced as 0 (IE bug(. It's a must
            // to check it in body.
            // 3. We get only 5xx from status, because it indicate
            // the server can't do a proper response, thus we can't
            // expect it provide a good Header in body.
            var result = {};
            if ((!jqXHR) || typeof jqXHR.status == "undefined") {
                this._Verbose("IE8/IE9 general error handler.");
                result["statuscode"] = -1;
            }
            else if (jqXHR.status == 304) {
                var expires = jqXHR.getResponseHeader("Expires");
                this._Verbose("expires: " + expires);
                result["expires"] = expires ? Date.parse(expires) : null;
                result["etag"] = jqXHR.getResponseHeader("ETag");
                result["statuscode"] = jqXHR.status;
            }
            else if (jqXHR.status >= 500) {
                result["statuscode"] = jqXHR.status;
            }
            else if (jqXHR.status == 0) {
                // Workaround for known server bug: ECS-1904
                this._Verbose("Blocked by same-origin policy.");
                result["statuscode"] = -1;
            }
            else {
                try {
                    result["statuscode"] = jqXHR.status;
                    var responseJson = JSON.parse(jqXHR.responseText);
                    var header = this._GetHeader(responseJson);
                    if (header) {
                        // When we find header, we trust server will
                        // return corect values.
                        this._Verbose("Header found in body.");
                        var expires = header["expires"];
                        result["expires"] = expires ? Date.parse(expires) : null;
                        result["statuscode"] = parseInt(header["statuscode"]);
                        result["etag"] = header["etag"];
                    }
                    else {
                        this._Error("Header missing in response body.");
                    }
                    result["data"] = responseJson;
                }
                catch (e) {
                    this._Error("Failed when parsing");
                }
            }
            this._Verbose("Return code = " + result["statuscode"]);
            return result;
        };
        EcsClientImpl.prototype._GetHeader = function (json) {
            // Make sure Headers can always be kept in same spelling.
            var headers = null;
            for (var namespace in json) {
                if (namespace.toLowerCase() == "headers") {
                    headers = {};
                    for (var key in json[namespace]) {
                        headers[key.toLowerCase()] = json[namespace][key];
                    }
                    break; // Assume server returns only one header.
                }
            }
            return headers;
        };
        /******* TEST_INJECTION_START *******/
        /******* The following function is only defined for test injection, you should never invoke them *********/
        EcsClientImpl.prototype.__GetListenerArray = function () {
            return this._listeners;
        };
        EcsClientImpl.prototype.__UpdateServers = function (servers) {
            this._config.servers = servers;
        };
        EcsClientImpl.prototype.__GetQueryParameters = function () {
            return this._queryParams;
        };
        return EcsClientImpl;
    }());
})(ecs || (ecs = {}));
;
/**
 * The telemetry web worker
 * Responsible for communicating between the app and the web worker on the web worker's side
 * Handle calls to telemetry
 */
var TelemetryWebWorker = (function () {
    function TelemetryWebWorker(worker) {
        var _this = this;
        this.worker = worker;
        this.telemetry = new microsoft.applications.telemetry._sender.TelemetryManagerImpl();
        this.ariaLoggers = {};
        this.messageHandlers = {};
        microsoft.applications.telemetry.globalTelemetryManager = this.telemetry;
        // handle messages from app
        this.worker.addEventListener('message', function (event) {
            if (!event || !event.data || !event.data.name) {
                return;
            }
            var messageHandler = _this.messageHandlers[event.data.name];
            if (!messageHandler) {
                _this.Error('Unhandled webworker message - ' + JSON.stringify(event.data));
                return;
            }
            messageHandler(event.data.params);
        });
        this.messageHandlers['start'] = function (params) {
            _this.telemetry.Start();
        };
        this.messageHandlers['stop'] = function (params) {
            _this.telemetry.Stop();
        };
        this.messageHandlers['flush'] = function (params) {
            var partialFlushesLeft = 8;
            var onPartialFlush = function () {
                // todo: depostu - don't use internal ARIA SDK apis
                // unfortunately atm there's no way to flush all the events cached by telemetry manager
                var didFlushEverything = _this.telemetry._eventsCache.IsEmpty();
                var didFlushTooManyTimes = --partialFlushesLeft === 0;
                if (didFlushEverything || didFlushTooManyTimes) {
                    _this.worker.postMessage({ name: 'flushed' });
                }
                else {
                    _this.telemetry.Flush(onPartialFlush);
                }
            };
            onPartialFlush();
        };
        this.messageHandlers['initialize'] = function (params) {
            if (params.config) {
                params.config.log = _this;
            }
            _this.telemetry.Initialize(params.config);
            microsoft.applications.telemetry.LogManager.initialize(params.documentInfo, params.appToken);
        };
        this.messageHandlers['newLogger'] = function (params) {
            _this.ariaLoggers[params.name] = new microsoft.applications.telemetry.Logger(params.token);
        };
        this.messageHandlers['sendAsync'] = function (params) {
            _this.telemetry.SendAsync(params.tenantToken, params.events);
        };
        this.messageHandlers['changeMaxPackageSizeInKB'] = function (params) {
            _this.telemetry.__ChageMaxPackageSizeInKB(params.size);
        };
        this.messageHandlers['logEvent'] = function (params) {
            var ariaLogger = _this.ariaLoggers[params.name];
            ariaLogger.logEvent(params.eventProperties);
        };
        // log session and callback to report the new session id
        this.messageHandlers['logSession'] = function (params) {
            var ariaLogger = _this.ariaLoggers[params.name];
            ariaLogger.logSession(params.state, params.properties);
            _this.worker.postMessage({
                name: 'sessionId',
                params: {
                    name: params.name,
                    sessionId: ariaLogger.getSessionId()
                }
            });
        };
        this.messageHandlers['setContext'] = function (params) {
            microsoft.applications.telemetry.LogManager.setContext(params.key, params.value, params.pii);
        };
        this.messageHandlers['setUserId'] = function (params) {
            microsoft.applications.telemetry.LogManager.getSemanticContext().setUserId(params.id);
        };
    }
    TelemetryWebWorker.prototype.Verbose = function (msg) {
    };
    TelemetryWebWorker.prototype.Info = function (msg) {
        this.worker.postMessage({
            name: 'info',
            params: {
                msg: msg
            }
        });
    };
    TelemetryWebWorker.prototype.Error = function (msg) {
        this.worker.postMessage({
            name: 'error',
            params: {
                msg: msg
            }
        });
    };
    return TelemetryWebWorker;
}());
var telemetryWebWorker = new TelemetryWebWorker(self);

//# sourceMappingURL=https://statics.teams.microsoft.com/hashedjs/webworker.js-755f62a8.map